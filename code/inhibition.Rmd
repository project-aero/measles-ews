---
title: "Inhibition estimate to characterize vaccination regime"
output:
  html_document:
    df_print: paged
---

This notebook reproduces the simulations that are done for calculation of early warning signals in `simulate-elimination-grid.R`. Then several plots and calculations are added to provide insight into why some early warning signals perform poorly and some new, better performing, indicators are calculated.

```{r simulation_reproduction}

# Define function for vaccination campaign --------------------------------

rho_curve_ramp <- function(t, start = 52*4, speed = 0.0015){
  ifelse(
    t <= start,
    rho <- 0.7,
    rho <- min(0.7 + (t - start)*speed, 1)  # linear
  )
  return(rho)
}


# Set up grid of vaccination roll out speeds ------------------------------


speed_grid <- seq(0.000015, 0.0001, length.out = 6)  # linear


# Load libraries ----------------------------------------------------------

library(tidyverse)
library(pomp)
library(foreach)
library(doParallel)  # functions for parallel computing

if(parallel::detectCores() <= length(speed_grid)){
  registerDoParallel(cores = detectCores() - 1)
} else{
  registerDoParallel(cores = length(speed_grid))
}

source("make-pomp-simulator-function.R")
cities <- c("Agadez", "Maradi", "Niamey", "Zinder")
sims <- list()
for(do_city in cities){
  
  # Load fitted parameters and pomp model -----------------------------------
  
  mle_file <- paste0("../results/initial-mif-lls-", do_city, ".csv")
  mles <- read.csv(mle_file) %>% 
    slice(2:n()) %>%  # ignore first row of storage NAs
    filter(loglik == max(loglik, na.rm = TRUE)) %>%
    dplyr::select(-do_grid, -loglik, -loglik_se)
  
  pomp_file <- paste0("./measles-pomp-object-", do_city, ".RDS")
  fitted_pomp <- readRDS(pomp_file)
  N1 <- round(mean(fitted_pomp@covar[, "N"]))
  
  # Simulate from the new pomp object ---------------------------------------
  
  temp_res <- list()
  outsims <- foreach(i = speed_grid,
                     .packages = c("pomp", "tidyverse", "dplyr"), 
                     .combine = "rbind") %do%
  {
    years <- 100
    weeks <- years*52
    days <- years*365
    vacc_coverage_ts <- sapply(0:days, FUN = rho_curve_ramp, 
                               start = 50*365, speed = i)

    simulator_pomp <- make_pomp_simulator(
      do_city, 
      mles, 
      years_to_sim = years, 
      initial_population_size = N1, 
      susc_discount = 1,
      exposed_discount = 1,
      infected_discount = 1,
      vacc_coverage_ts = vacc_coverage_ts
    )
    
    temp_res[[as.character(i)]] <- simulate(
      simulator_pomp,
      nsim = 10,
      as.data.frame = TRUE,
      include.data = FALSE,
      seed = 172856) %>%
      as_tibble() %>% 
      mutate(R0_seas = RE_seas / S * N1) %>% 
      mutate(wstop = min(time[vacc_discount <= 1 / max(R0_seas)])) %>% 
      mutate(wstart = 2 * 50 - wstop) %>%
      mutate(vacc_coverage = 1 - vacc_discount) %>%
      select(-vacc_discount, -starts_with("xi")) %>% 
      group_by(sim) %>% nest()

  }
  sims[[do_city]] <- bind_rows(temp_res, .id = "speed")
}
sims <- bind_rows(sims, .id = "city")

```


```{r fit_S_model}

sim_model <- function(df){
  stats::loess(S ~ time, span = 52 / (nrow(df) * 2), data = df)
}

simfit <- sims %>% mutate(model = purrr::map(data, sim_model))

simfit <- simfit %>% 
  mutate(pred = purrr::map2(data, model, modelr::add_predictions))

preds <- unnest(simfit, pred)

preds %>% filter(sim == 2 & time < 10) %>% 
  ggplot(aes(x = time, y = S)) + geom_point(size = 1, alpha = 0.5) + 
  geom_line(aes(y = pred)) + 
  facet_grid(city ~ as.numeric(speed), scales = "free_y")

```

The random number streams for each vaccination speed are identical due to the parallelization. So before year 50, each simulation is identical. This duplication is not a problem regarding the validity of our results because the results are based on the difference in indicators at different windows within a simulation. But if we ever need to improve the running time of our code removing these duplicated calculations would be an easy way to do it.

```{r calc_ieps}

iepsum <- function(df){
  sdrop <- diff(df$pred) < 0
  is_epi <- c(FALSE, sdrop)
  epirle <- rle(is_epi)
  is_scrap <- epirle$lengths[!epirle$values] < 5
  epirle$values[!epirle$values][is_scrap] <- TRUE 
  epirle$values[!epirle$values] <- 1 + seq(1, sum(!epirle$values))
  iepids <- inverse.rle(epirle)
  
  miep <- max(iepids)
  splt <- split(df$S, iepids)
  splt_time <- split(df$time, iepids)
  trimsplt <- splt[-miep][-1]
  trimsplt_time <- splt_time[-miep][-1]
  
  iep_lens <- sapply(trimsplt, length)
  iep_s0 <- sapply(trimsplt, "[", 1)
  iep_sfin <- mapply(function(x, y) x[y], x = trimsplt, y = iep_lens)
  iep_t0 <- sapply(trimsplt_time, "[[", 1)
  iep_tfin <- mapply(function(x, y) x[y], x = trimsplt_time, y = iep_lens)
  epi_sizes <- c(iep_sfin[-length(iep_lens)] - iep_s0[-1], NA)
  ts <- df %>% select(time, S, I, R0_seas) %>% mutate(iepids = iepids)
  iepsum <- tibble(iepid = names(trimsplt), s0 = iep_s0, sfin = iep_sfin, 
                   t0 = iep_t0, tfin = iep_tfin, iep_weeks = iep_lens, 
                   epi_sizes = epi_sizes, wstart = unique(df$wstart),
                   wstop = unique(df$wstop))
  list(augts = ts, iepsum = iepsum)
}

iepsumout <- purrr::map(simfit$pred, iepsum)
simfit2 <- add_column(simfit, iepts = purrr::map(iepsumout, "augts")) %>%
  add_column(iepsum = purrr::map(iepsumout, "iepsum"))

simfitred <- simfit2 %>% filter(sim <= 3 & speed == "1.5e-05")
plotwinstop <- 50
plotwinstart <- 40
preds <- unnest(simfitred, pred) %>% filter(time < plotwinstop & time > plotwinstart)
simsum <- unnest(simfitred, iepsum) %>% filter(tfin < plotwinstop & t0 > plotwinstart)

ggplot(preds, aes(x = time, y = S)) + 
  geom_point() + 
  geom_line(aes(y = pred), col = "red") + 
  geom_rect(data = simsum, 
            aes(xmin = t0, xmax = tfin, group = iepid), 
            inherit.aes = FALSE, ymin = -Inf, ymax = Inf,
            fill = "grey", alpha = 0.2) + 
  facet_grid(city ~ sim, scales = "free_y") + 
  theme_classic()

ggplot(preds, aes(x = time, y = I)) + 
  geom_point() + 
  geom_rect(data = simsum, 
            aes(xmin = t0, xmax = tfin, group = iepid), 
            inherit.aes = FALSE, ymin = -Inf, ymax = Inf,
            fill = "grey", alpha = 0.2) + 
  facet_grid(city ~ sim, scales = "free_y") + 
  theme_classic()



```

We show 3 ten-year windows of the simulated time series of S and I for each city. The number on the top of each column of panels indicates the simulation replicate identifier. 
The dynamics may be separated into 2 distinct phases: One in which the number of susceptibles builds slowly and another in which epidemics occur and the number susceptibles drops rapidly. The periods containing conspicuous epidemic spikes can be readily located simply by fitting a smoother to the S variable and finding the regions where S does not increase for more than 5 weeks. We use this method to split the time series into epidemics and inter-epidemic periods. The inter-epidemic periods that are fully within the plotted window are indicated by a light grey plot background. Clearly the length of these inter-epidemic periods is highly variable for the parameters for each city. Also, the rates at which suseptibles recover relative to the size of a large epidemic varies widely among cities.

To better understand the behavior of the model in the epidemic phases, we develop a statistical model to the amount by which S drops in these phases. 

```{r epi_size_map}

prog_id <- function(t1, t2) {
  if (t1 > 50) {
    1
  } else if (t2 < 50) {
    0
  } else {
    0.5
  }
}

sizesum2 <- unnest(simfit2, iepsum) %>% 
  filter(tfin < wstop & t0 > wstart) %>% 
  filter(!is.na(epi_sizes) & epi_sizes > 0) %>%
  mutate(vacc_program = purrr::map2_dbl(t0, tfin, prog_id)) %>% 
  mutate(start_season = tfin - round(tfin)) %>% 
  mutate(cityf = as.factor(city))
  
sizegam <- mgcv::gam(
  epi_sizes ~ s(sfin, by = cityf) + s(start_season) + vacc_program + cityf, 
  data = sizesum2)
mgcv::gam.check(sizegam)

e <- residuals(sizegam); fv <- fitted(sizegam)
lm(log(e^2) ~ log(fv))

sizegam2 <- mgcv::gam(
  (epi_sizes)^.25 ~ s(sfin, by = cityf) + s(start_season) + vacc_program + cityf, 
  data = sizesum2)

mgcv::gam.check(sizegam2)

sizegam3 <- mgcv::gam(
  (epi_sizes) ~ s(sfin, by = cityf) + s(start_season) + vacc_program + cityf, 
  data = sizesum2, family = Gamma(link = log))

mgcv::gam.check(sizegam3)

sizegam4 <- mgcv::gam(
  log(epi_sizes) ~ s(sfin, by = cityf) + s(start_season) + vacc_program + cityf, 
  data = sizesum2)

mgcv::gam.check(sizegam4)
m <- sizegam2
```

The variance-mean relationship rules out a standard gaussin model with identiy link function, so we try log transform, 4th-root transform, gamma log-link models. The fourth root transform seems to have the best diagnostic plots.


```{r model_viewing}

summary(m)
plot(m, ylim = c(-10, 10))
mgcv::vis.gam(m, plot.type = "contour", view = c("vacc_program", "sfin"))
mgcv::vis.gam(m, plot.type = "contour", view = c("vacc_program", "start_season"))
anova(m)
```

The vaccination increase leads to a slight reduction in epidemic size. This makes sense because with higher vaccination rates, there is less fuel added to the epidemics as they transpire. Nevertheless, this effect is small relative to that of the initial number of susceptibles and the time of the year at which the epidemic begins. The implication is that epidemic size will not be a particularly good indicator of the success of vaccination increases in reducing susceptible recruitment.

On second thought, vaccination rates increasing will likely affect the distribution of the initial number of susceptibles and initial season. With higher vaccination rates, the number of susceptibles can change more between seasons. So by this mechanism the change in the vaccination program could have a larger effect on the distribution of epidemic sizes. So we next plot the distribution of initial conditions for each vaccination regime.

```{r density_sf_season}

sizesum3 <- mutate(sizesum2, 
                   start_vacc = ifelse(vacc_program < 1, 
                                       "initial vacc", "increasing vacc."))

plot_ic_dist <- function(cit, df){
  g <- ggplot(data = filter(df, city == cit), 
         aes(x = start_season, y = sfin)) + 
    geom_point(alpha = 0.2) + 
    geom_density2d() + 
    facet_grid(as.numeric(speed) ~ start_vacc, scales = "free_y") + 
    ggtitle(cit)
  plot(g)
  return(0)
}

plot_icd_dist <- function(cit, df){
  dat <- df %>% filter(city == cit)
  ggplot(data = dat, aes(x = sfin)) + 
    geom_histogram() +
    facet_grid(as.numeric(speed) ~ start_vacc, scales = "free_y") + 
    ggtitle(cit)
}


lapply(cities, plot_ic_dist, df = sizesum3)

#plot_ic_dist("Niamey", df = sizesum3)
#plot_ic_dist("Zinder", df = sizesum3)


```








