---
title: "Inhibition estimate to characterize vaccination regime"
output:
  html_document:
    df_print: paged
bibliography: inhibition.bib
---

This notebook reproduces the simulations that are done for calculation of early warning signals in `simulate-elimination-grid.R`. Then several plots and calculations are added to provide insight into why some early warning signals perform poorly and some new, better performing, indicators are calculated.

```{r simulation_reproduction}

# Define function for vaccination campaign --------------------------------

rho_curve_ramp <- function(t, start = 52*4, speed = 0.0015){
  ifelse(
    t <= start,
    rho <- 0.7,
    rho <- min(0.7 + (t - start)*speed, 1)  # linear
  )
  return(rho)
}


# Set up grid of vaccination roll out speeds ------------------------------


speed_grid <- seq(0.000015, 0.0001, length.out = 6)  # linear
spdl <- as.character(speed_grid)

# Load libraries ----------------------------------------------------------

library(tidyverse)
library(pomp)
library(foreach)
library(doParallel)  # functions for parallel computing

if(parallel::detectCores() <= length(speed_grid)){
  registerDoParallel(cores = detectCores() - 1)
} else{
  registerDoParallel(cores = length(speed_grid))
}

source("make-pomp-simulator-function.R")
cities <- c("Agadez", "Maradi", "Niamey", "Zinder")
sims <- list()
for(do_city in cities){
  
  # Load fitted parameters and pomp model -----------------------------------
  
  mle_file <- paste0("../results/initial-mif-lls-", do_city, ".csv")
  mles <- read.csv(mle_file) %>% 
    slice(2:n()) %>%  # ignore first row of storage NAs
    filter(loglik == max(loglik, na.rm = TRUE)) %>%
    dplyr::select(-do_grid, -loglik, -loglik_se)
  
  pomp_file <- paste0("./measles-pomp-object-", do_city, ".RDS")
  fitted_pomp <- readRDS(pomp_file)
  N1 <- round(mean(fitted_pomp@covar[, "N"]))
  
  # Simulate from the new pomp object ---------------------------------------
  
  temp_res <- list()
  outsims <- foreach(i = speed_grid,
                     .packages = c("pomp", "tidyverse", "dplyr"), 
                     .combine = "rbind") %do%
  {
    years <- 100
    weeks <- years*52
    days <- years*365
    vacc_coverage_ts <- sapply(0:days, FUN = rho_curve_ramp, 
                               start = 50*365, speed = i)

    simulator_pomp <- make_pomp_simulator(
      do_city, 
      mles, 
      years_to_sim = years, 
      initial_population_size = N1, 
      susc_discount = 1,
      exposed_discount = 1,
      infected_discount = 1,
      vacc_coverage_ts = vacc_coverage_ts
    )
    
    temp_res[[as.character(i)]] <- simulate(
      simulator_pomp,
      nsim = 100,
      as.data.frame = TRUE,
      include.data = FALSE,
      seed = 172856) %>%
      as_tibble() %>% 
      mutate(R0_seas = RE_seas / S * N1) %>% 
      mutate(wstop = min(time[vacc_discount <= 1 / max(R0_seas)])) %>% 
      mutate(wstart = 2 * 50 - wstop) %>%
      mutate(vacc_coverage = 1 - vacc_discount) %>%
      select(-vacc_discount, -starts_with("xi")) %>% 
      group_by(sim) %>% nest()

  }
  sims[[do_city]] <- bind_rows(temp_res, .id = "speed") %>% 
    mutate(speedf = factor(speed, levels = spdl))
}
sims <- bind_rows(sims, .id = "city")

```


```{r fit_S_model}

sim_model <- function(df){
  stats::loess(S ~ time, span = 52 / (nrow(df) * 2), data = df)
}

simfit <- sims %>% mutate(model = purrr::map(data, sim_model))

simfit <- simfit %>% 
  mutate(pred = purrr::map2(data, model, modelr::add_predictions))

preds <- unnest(simfit, pred)

preds %>% filter(sim == 2 & time < 10) %>% 
  ggplot(aes(x = time, y = S)) + geom_point(size = 1, alpha = 0.5) + 
  geom_line(aes(y = pred)) + 
  facet_grid(city ~ speedf, scales = "free_y")

```

The random number streams for each vaccination speed are identical due to the parallelization. So before year 50, each simulation for a city with the same replicate identifier is identical. This duplication is not a problem regarding the validity of our results because the results are based on the difference in indicators at different windows within a given city and speed combination. But if we ever need to improve the running time of our code removing these duplicated calculations would be an easy way to do it.

```{r calc_ieps}

iepsum <- function(df){
  sdrop <- diff(df$pred) < 0
  is_epi <- c(FALSE, sdrop)
  epirle <- rle(is_epi)
  is_scrap <- epirle$lengths[!epirle$values] < 5
  epirle$values[!epirle$values][is_scrap] <- TRUE 
  epirle$values[!epirle$values] <- 1 + seq(1, sum(!epirle$values))
  iepids <- inverse.rle(epirle)
  
  miep <- max(iepids)
  splt <- split(df$S, iepids)
  splt_time <- split(df$time, iepids)
  trimsplt <- splt[-miep][-1]
  trimsplt_time <- splt_time[-miep][-1]
  
  iep_lens <- sapply(trimsplt, length)
  iep_s0 <- sapply(trimsplt, "[", 1)
  iep_sfin <- mapply(function(x, y) x[y], x = trimsplt, y = iep_lens)
  iep_t0 <- sapply(trimsplt_time, "[[", 1)
  iep_tfin <- mapply(function(x, y) x[y], x = trimsplt_time, y = iep_lens)
  epi_sizes <- c(iep_sfin[-length(iep_lens)] - iep_s0[-1], NA)
  ts <- df %>% select(time, S, I, R0_seas) %>% mutate(iepids = iepids)
  iepsum <- tibble(iepid = names(trimsplt), s0 = iep_s0, sfin = iep_sfin, 
                   t0 = iep_t0, tfin = iep_tfin, iep_weeks = iep_lens, 
                   epi_sizes = epi_sizes, wstart = unique(df$wstart),
                   wstop = unique(df$wstop))
  list(augts = ts, iepsum = iepsum)
}

iepsumout <- purrr::map(simfit$pred, iepsum)
simfit2 <- add_column(simfit, iepts = purrr::map(iepsumout, "augts")) %>%
  add_column(iepsum = purrr::map(iepsumout, "iepsum"))

simfitred <- simfit2 %>% filter(sim <= 3 & speed == "1.5e-05")
plotwinstop <- 50
plotwinstart <- 40
preds <- unnest(simfitred, pred) %>% filter(time < plotwinstop & time > plotwinstart)
simsum <- unnest(simfitred, iepsum) %>% filter(tfin < plotwinstop & t0 > plotwinstart)

ggplot(preds, aes(x = time, y = S)) + 
  geom_point() + 
  geom_line(aes(y = pred), col = "red") + 
  geom_rect(data = simsum, 
            aes(xmin = t0, xmax = tfin, group = iepid), 
            inherit.aes = FALSE, ymin = -Inf, ymax = Inf,
            fill = "grey", alpha = 0.2) + 
  facet_grid(city ~ sim, scales = "free_y") + 
  theme_classic()

ggplot(preds, aes(x = time, y = I)) + 
  geom_point() + 
  geom_rect(data = simsum, 
            aes(xmin = t0, xmax = tfin, group = iepid), 
            inherit.aes = FALSE, ymin = -Inf, ymax = Inf,
            fill = "grey", alpha = 0.2) + 
  facet_grid(city ~ sim, scales = "free_y") + 
  theme_classic()

```

We show 3 ten-year windows of the simulated time series of S and I for each city. The number on the top of each column of panels indicates the simulation replicate identifier. 
The dynamics may be separated into 2 distinct phases: One in which the number of susceptibles builds slowly and another in which epidemics occur and the number susceptibles drops rapidly. The periods containing conspicuous epidemic spikes can be readily located simply by fitting a smoother to the S variable and finding the regions where S does not increase for more than 5 weeks. We use this method to split the time series into epidemics and inter-epidemic periods. The inter-epidemic periods that are fully within the plotted window are indicated by a light grey plot background. Clearly the length of these inter-epidemic periods is highly variable for the parameters for each city. Also, the rates at which suseptibles recover relative to the size of a large epidemic varies widely among cities.

To better understand the behavior of the model in the epidemic phases, we develop a statistical model to the amount by which S drops in these phases. 

```{r epi_size_map}

prog_id <- function(t1, t2) {
  if (t1 > 50) {
    1
  } else if (t2 < 50) {
    0
  } else {
    0.5
  }
}

sizesum2 <- unnest(simfit2, iepsum) %>% 
  filter(tfin < wstop & t0 > wstart) %>% 
  filter(!is.na(epi_sizes) & epi_sizes > 0) %>%
  mutate(vacc_program = purrr::map2_dbl(t0, tfin, prog_id)) %>% 
  mutate(start_season = tfin - round(tfin)) %>% 
  mutate(cityf = as.factor(city))
  
sizegam <- mgcv::gam(
  epi_sizes ~ s(sfin, by = cityf) + s(start_season) + vacc_program + cityf, 
  data = sizesum2)
mgcv::gam.check(sizegam)

e <- residuals(sizegam); fv <- fitted(sizegam)
lm(log(e^2) ~ log(fv))

sizegam2 <- mgcv::gam(
  (epi_sizes)^.25 ~ s(sfin, by = cityf) + s(start_season) + vacc_program + cityf, 
  data = sizesum2)

mgcv::gam.check(sizegam2)

sizegam3 <- mgcv::gam(
  (epi_sizes) ~ s(sfin, by = cityf) + s(start_season) + vacc_program + cityf, 
  data = sizesum2, family = Gamma(link = log))

mgcv::gam.check(sizegam3)

sizegam4 <- mgcv::gam(
  log(epi_sizes) ~ s(sfin, by = cityf) + s(start_season) + vacc_program + cityf, 
  data = sizesum2)

mgcv::gam.check(sizegam4)
m <- sizegam2
```

The variance-mean relationship rules out a standard gaussian model with identiy link function, so we try log transform, 4th-root transform, gamma log-link models. The fourth root transform seems to have the best diagnostic plots.


```{r model_viewing}

summary(m)
plot(m, ylim = c(-10, 10))
mgcv::vis.gam(m, plot.type = "contour", view = c("vacc_program", "sfin"))
mgcv::vis.gam(m, plot.type = "contour", view = c("vacc_program", "start_season"))
anova(m)
```

The vaccination increase leads to a slight reduction in epidemic size. This makes sense because with higher vaccination rates, there is less fuel added to the epidemics as they transpire. Nevertheless, this effect is small relative to that of the initial number of susceptibles and the time of the year at which the epidemic begins. The implication is that epidemic size will not be a particularly good indicator of the success of vaccination increases in reducing susceptible recruitment.

On second thought, vaccination rates increasing will likely affect the distribution of the initial number of susceptibles and initial season. With higher suscptible recruitment rates, the number of susceptibles can change more between seasons. So by this mechanism the change in the vaccination program could have a larger effect on the distribution of epidemic sizes. So we next plot the distribution of initial conditions for each vaccination regime.

```{r density_sf_season}

sizesum3 <- mutate(sizesum2, 
                   start_vacc = ifelse(vacc_program < 1, 
                                       "initial vacc", "increasing vacc"))

plot_ic_dist <- function(cit, df){
  g <- ggplot(data = filter(df, city == cit), 
         aes(x = start_season, y = sfin)) + 
    geom_point(alpha = 0.2) + 
    geom_density2d() + 
    facet_grid(speedf ~ start_vacc, scales = "free_y") + 
    ggtitle(cit)
  plot(g)
  return(0)
}

lapply(cities, plot_ic_dist, df = sizesum3)

```

To a greater or lesser extent, the distribution of the number of suceptibles at the beginning of the epidemic is higher in the initial vaccination period. It seems likely that this is due to the larger amount by which the suscpetibles can grow in the off-season. Incidentally, it seems that there are very few complete interepidemic periods in the increasing-vaccination Agadez time series for faster vaccination rate ramp-ups.  Those parameters for that city may be outside of the region in which the epidemic classification scheme makes sense.

```{r plot_inter-epi-dist}

plot_iep_dist <- function(df){
  g <- ggplot(data = df, aes(x = iep_weeks, color = start_vacc)) + 
    geom_density() + 
    facet_grid(speedf ~ city, scales = "free_y")
  plot(g)
  return(0)
}

plot_iep_dist(sizesum3)

```

The distribution of interepidemic periods is quite similar whether or not the interepidemic period includes the time when vaccination started to increase. When they are noticeably different, it seems that the probability mass is shifted downward in the period in which the vaccination rate is increasing. Thus contrary to the expectation that we have in linear models, the interepidemic period is smaller closer to the elimination threshold (i.e., when the model equilibrium is less stable). This seems to be a consequence of epidemics starting with fewer susceptibles and thus undershooting the equilibrium value of S less. 

```{r interepi_AUC}

ggbar <- function(df, depvar){
  df %>% ggplot(aes(fill = speedf, y = !!enquo(depvar), x = city)) + 
  geom_bar(stat = "identity", position = "dodge")
}

calc_auc <- function(predictions, is_null){
    r <- rank(predictions)
    r1 <- sum(r[!is_null])
    n1 <- sum(!is_null)
    n2 <- sum(is_null)
    (r1 - n1 * (n1 + 1) / 2) / (n1 * n2)
}

sizesum3 %>% group_by(speedf, city) %>% 
  summarise(iepAUC = calc_auc(predictions = iep_weeks, 
                              is_null = start_vacc == "initial vacc")) %>%
  ggbar(iepAUC)

```

The frequent AUC statistics below 0.5 confirm and summarise that the interepidemic periods are indeed typically shorter in the "null" period in which the vaccination rate stays at 0.7.

To further summarize the dynamics for a cyclic point of view, we next calculate the AUC of the epidemic size distributions.

```{r epi_size_AUC}

sizesum3 %>% group_by(speedf, city) %>% 
  summarise(epi_sizeAUC = calc_auc(predictions = epi_sizes, 
                              is_null = start_vacc == "initial vacc")) %>% 
  ggbar(epi_sizeAUC)

```

The AUC statistics below 0.5 tell us that epidemic sizes are typically smaller following the increase in vaccination rate. This reduction is consistent with two prior observations. First, we have noted that the initial number of susceptibles is typically larger in the steady-vaccination rate period. Second, our GAM model told us that, even when the initial number of susceptibles is the same, epidemics tend to be smaller in the increasing-vaccination period. 

The reduction in epidemic size must explain why the interepidemic periods become smaller as vaccination rates increase. In our model, the threshold value of $S$ above which an epidemic is possible never changes. With higher vaccination rates, it must take the susceptible population (typically) longer to grow to any given level starting from the same point. Evidently, the number of susceptibles is sufficiently higher at the beginning of the interepidemic periods to overcompensate for this lower growth rate. Thus the susceptible population typically reaches its critical value in a shorter time.

The interepidemic period is not a robust indicator of the slowing down in susceptible growth, which is how critical slowing down occurs in this model. However, the simple mean number of cases seems like a suitable alternative indicator that is observable. In the long run, lower rates of susceptible birth should lead to lower average rates of infection.

```{r calc-mean-cases-indicator}

tst <- unnest(sims, data) %>% filter(time > wstart & time < wstop) %>%
  mutate(vacc_prog = ifelse(time < 50, "steady", "increasing")) %>%
  group_by(city, speedf, sim, vacc_prog) %>%
  summarize(mean_cases = mean(cases))

tst %>% ggplot(aes(x = mean_cases, color = vacc_prog)) + 
    geom_density() + 
    facet_grid(speedf ~ city, scales = "free")

```


```{r calc-mean-cases-auc}

tst %>% group_by(city, speedf) %>% 
  summarise(mean_casesAUC = calc_auc(predictions = mean_cases,
                                     is_null = vacc_prog == "steady")) %>% 
  ggbar(depvar = mean_casesAUC)

```

The AUCs for Maradi and Niamey are below 0.1 at all speeds, which tells us that the mean number of cases is a good indicator for these cities. However, performance is less than stellar for Agadez and Zinder. Thus there is reason to seek a better performing indicator. 

One problem with the mean is that it does not account for the recent epidemic history of the cities. Each epidemic inhibits later epidemics by depleting the susceptible pool. We have already seen that epidemics tend to be larger in the steady vaccination period. This can work to counterbalance the apparent decrease in the mean number of cases in the increasing vaccination period. For example, if a large epidemic occurs just before the beginning of the first window but not the second window, then we might observe fewer cases on average in the first window even though susceptible recruitment rates are higher. An indicator that is more resistant to this problem is one that calculates the mean number of cases conditional on recent epidemic history. Next, we examine the performance of a simple version of such an indicator. 

Our proposed indicator amounts to fitting a simple regression model. We first aggregate the data to yearly case counts and then calculate a convolutional filter of the yearly time series. Weights for the filter decrease linearly to zero in time since the current year so that more recent epidemics have the most weight. We additionally calculate a rough estimate of the expected epidemic size for the hypothetical scenario that no recent epidemics occurred.    

If vaccination is reducing the susceptible recruitment rate, we expect recent epidemics to more strongly inhibit current epidemics. We can quantify this inhibitory effect as the mean number of cases conditional on the recent epidemic history. A first step towards quantification of this inhibitory effect is to determine the size of a complete uninhibited epidemic, which can serve as reference point.

To obtain this reference point, we employ the following procedure. First, we average the top ten highest $R_0$ values for each city. We average 10 weekly values because we have observed that epidemics tend to occur on a timescale of about a month in the high-transmission season. Second, we convert these to numbers to effective reproduction numbers by multiplying by 0.3, the equilibrium fraction of susceptibles under the initial, steady vaccination program. Finally, we compute the expected epidemics sizes as $N (1 -\exp(- R_E) )$, where $N$ is the equilibrium population size for each city in our simulations. This formula uses the standard final size approximation for an epidemic in a closed population when the reproduction number is much greater than one [@diekmann2013, p. 15].

```{r calc-baseline-epi-size}

N <- unnest(sims, data) %>% group_by(city) %>% slice(30) %>% 
  mutate(N1 = R0_seas * S / (RE_seas), N2 = S + E + I + R) %>% 
  select(city, N1, N2) 

R0 <- unnest(sims, data) %>% filter(speedf == spdl[1]) %>% 
  filter(sim == 1) %>% filter(trunc(time) == 50) %>% 
  group_by(city) %>% top_n(n = 10, wt = R0_seas) %>% 
  select(city, time, R0_seas) %>% 
  summarize(mean_high_R0 = mean(R0_seas))

intercepts <- N %>% inner_join(R0, by = "city") %>% 
  mutate(base_size = N1 * (1 - exp(-mean_high_R0 * 0.7)))

```

Now the inhibition effect of recent epidemic history is modeled as the extent to which epidemic size decreases with the filter of past epidemics. We assume a linear relationship for simplicity. We estimate this effect in both the steady and increasing vaccination time periods by a least-squares model fit. If the epidemic size decreases more with the filter in the increasing vaccination period, then the conclusion is that past epidemics are inhibiting current epidemics more in this period. Consequently, the AUC of this indicator can be calculated as the fraction of times in our data in which we conclude that inhibition is stronger in the increasing-vaccination period.

```{r calc-inhibition-indicators}

filtcalc <- function(df, filter_len = 3){
  fltr <- rev(seq_len(filter_len))
  filtfun <- function(x) {
    stats::filter(x, filter = fltr, 
                  sides = 1, method = "convolution") %>%
      as.numeric()
  }
  df %>% mutate(year = round(time)) %>%
    group_by(year) %>% summarise(cases_yr = sum(cases)) %>% 
    mutate(filt = filtfun(cases_yr),
           cases_yrnxt = lead(cases_yr, 1),
           vacc_prog = ifelse(year < 50, "steady", "increasing")) %>% 
    select(year, cases_yrnxt, filt, vacc_prog) %>%
    filter(year > df$wstart[1] & year < df$wstop[1])
}

inhib_model <- function(int, df){
  tryCatch(lm(I(int - cases_yrnxt) ~ 0 + filt + filt:vacc_prog, data = df),
           error = function(e) browser())
}

desmat <- sims %>% select(city, speedf) %>% 
  expand(city, speedf, flen = c(4, 8, 12, 16, 20))

tsf <- sims %>% inner_join(desmat) %>% unnest(data) %>% 
  group_by(city, speedf, sim, flen) %>% nest() %>% 
  mutate(filtdf = purrr::map2(data, flen, filtcalc))

tsf2 <- intercepts %>% select(city, base_size) %>% 
  inner_join(tsf, by = "city") %>%
  ungroup() %>%
  mutate(inhibm = purrr::map2(base_size, filtdf, inhib_model),
         inhibests = purrr::map(inhibm, broom::tidy))

tsf2 %>% unnest(inhibests) %>% 
  filter(term == "filt:vacc_progincreasing") %>%
  group_by(city, speedf, flen) %>% 
  summarise(inhib_AUC = mean(estimate > 0)) -> tsf3

tsf3 %>% ggbar(inhib_AUC) + geom_hline(yintercept = 0.8) + facet_grid(flen~.)

```

# Summary of explanations for relative performance of all indicators of disease elimination



# References


