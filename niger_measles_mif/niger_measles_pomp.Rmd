---
title: "Measles state-space model fitted using `pomp`"
author: "Andrew Tredennick"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, message = FALSE, warning = FALSE)

library(tidyverse)   # data wrangling
library(lubridate)   # time and date functions
library(pomp)        # fitting state-space models with particle filtering
library(foreach)     # functions for parallel computing
library(doParallel)  # functions for parallel computing

registerDoParallel()
theme_set(theme_minimal())
```

## The data
First, we load the data and aggregate the weekly case reports into biweekly reports to match the time step of our process model.

```{r load-data}
file_name <- "../../niger_measles/niger_regional_1995_2005.csv"
niger_measles_raw <- read_csv(file_name, col_types = cols())

num_regions <- nrow(niger_measles_raw)
num_weeks <- ncol(niger_measles_raw) - 1  # subtract 1 from ncol() because first column are regions
weeks_per_year <- num_weeks/11
weeks <- rep(1:52, times = 11)

# Create a vector of years for all num_weeks
years <- rep(1995:2005, each = weeks_per_year)

# Function for calculating start of week based on week number and year
calculate_start_of_week = function(week, year) {
  date <- ymd(paste(year, 1, 1, sep="-"))
  week(date) = week
  return(date)
}

# Clean up the data frame
measles_data <- niger_measles_raw %>%
  gather(key = week, value = cases, -X1) %>%
  mutate(
    week_num = rep(1:num_weeks, each = num_regions),
    year = rep(years, each  = num_regions),
    week = rep(weeks, each = num_regions),
    date = calculate_start_of_week(week, year)
  ) %>%
  dplyr::rename(region = X1) %>%
  filter(region == "Niamey (City)")

# Read in population data and estimate births
population <- read_csv("../../niger_measles/district_pops.csv") %>%
  gather(key = year, value = population, -X1) %>%
  rename(district = X1) %>%
  filter(district == "Niamey I")

birth_rates <- read_csv("../../niger_measles/niger_crude_birth_rates.csv") %>%
  mutate(
    date = mdy(date),  # lubridate prefixes any 2digit year 00-68 with 20, not a problem for us though
    year = as.character(year(date)),
    rate_per_person = births_per_thousand/1000
  ) %>%
  select(year, rate_per_person)

births <- population %>%
  left_join(birth_rates, by = "year") %>%
  mutate(
    births_per_year = population * rate_per_person,
    births_per_week = births_per_year / 52
  )

# Aggregate weekly data to biweeks
biweek_data <- measles_data %>%
  mutate(biweek = rep(1:(n()/2), each = 2)) %>%
  group_by(biweek) %>%
  summarise(
    cases = sum(cases),
    date = min(date)
  ) %>%
  mutate(
    births = round(rep(births$births_per_week*2, each = 26)),
    population = round(rep(population$population, each = 26))
  )

ggplot(biweek_data, aes(x = date, y = cases)) +
  geom_point() +
  geom_line() +
  scale_y_sqrt() +
  labs(x = "Date", y = expression(paste(sqrt(Reported~cases))))
```

## The `pomp` object
Now we define the multiple parts of the `pomp` object for particle filtering.

### The process model
```{r process-model}
measles_process <- Csnippet(
  "
  double dN[2];
  double beta_r = beta_mu * (1 + dot_product(K, &xi1, &b1));
  double inv_lambda = exp(-beta_r * (I + psi));
  double var_epsilon = pow(sigma_dem,2)/inv_lambda +  sigma_env*sigma_env;
  inv_lambda *= (var_epsilon < 1.0e-6) ? 1 : rgamma(1/var_epsilon,var_epsilon);
  if(inv_lambda > 1){
    inv_lambda = 1;
  }
  double delta = rbinom(nearbyint(S), inv_lambda);
  dN[0] = delta + births;
  dN[1] = S - delta;
  S = nearbyint(dN[0]);
  I = nearbyint(dN[1]);
  "
)
```

### The measurement model
```{r measurement-model}
rmeas <- Csnippet(
  "
  cases = rnorm(rho*I, sqrt( pow(tau*I,2) + rho*I ) );
  if (cases > 0.0) {
    cases = nearbyint(cases);
  } else {
    cases = 0.0;
  }
  "
)
```

### The likelihood density model
```{r likelihood-model}
dmeas <- Csnippet(
  "
  double tol = 1.0e-25;
  double mean_cases = rho*I;
  double sd_cases = sqrt(pow(tau*I, 2) + mean_cases);
  if (cases > 0.0) {
    lik = pnorm(cases+0.5,mean_cases,sd_cases,1,0) - pnorm(cases-0.5,mean_cases,sd_cases,1,0) + tol; 
  } else{
    lik = pnorm(cases+0.5,mean_cases,sd_cases,1,0) + tol;
  }
  if (give_log) lik = log(lik);
  "
)
```

### Mapping of transformations
This is information for `pomp` in terms of parameter transformations (e.g., to enforce strictly positive parameter values) and initial conditions estimates.

```{r mapping}
# Map initial value parameters to initial values of states
init <- Csnippet(
  "
  I = nearbyint(I_0);
  S = nearbyint(S_0);
  "
)

# Set up parameter transformations
to_est <- Csnippet(
  "
  Tbeta_mu = log(beta_mu);
  Trho = logit(rho);
  Ttau = log(tau);
  Tsigma_dem = log(sigma_dem);
  Tsigma_env = log(sigma_env);
  TS_0 = log(S_0);
  TI_0 = log(I_0);
  Tpsi = log(psi);
  "
)

from_est <- Csnippet(
  "
  Tbeta_mu = exp(beta_mu);
  Trho = expit(rho);
  Ttau = exp(tau);
  Tsigma_dem = exp(sigma_dem);
  Tsigma_env = exp(sigma_env);
  TS_0 = exp(S_0);
  TI_0 = exp(I_0);
  Tpsi = exp(psi);
  "
)
```

### Setup data and covariate tables
`pomp` requires separate `data` and `covar` tables, each with the same time column.
We set those up here.

```{r data-and-covar}
# Fetch observations
obs_data <- biweek_data %>%
  dplyr::select(biweek, cases) %>%
  mutate(cases = round(cases, 0))

# Generate basis functions for seasonality
bspline_basis <- periodic.bspline.basis(
  obs_data$biweek,
  nbasis = 6,
  degree = 3,
  period = 26,
  names = "xi%d"
) %>%
  as_tibble()

# Combine with births data for covariate table
covar_data <- biweek_data %>%
  dplyr::select(biweek, births) %>%
  arrange(biweek) %>%
  bind_cols(bspline_basis)
```

### Combine everything into a `pomp` object
Now we take all the objects we created above and put them together in a `pomp` container.
We also set reasonable parameter values as place holders for making sure the model can simulate data that at least qualitatively mimics the behavior of the data.

```{r pomp-container}
# Set some realistic parameter values for testing via simulation
params <- c(
  beta_mu = 0.00001,
  b1 = 3,
  b2 = 0,
  b3 = 1.5,
  b4 = 6,
  b5 = 5,
  b6 = 3,
  psi = 1,
  rho = 0.5,
  tau = 0.1,
  sigma_env = 0.0001,
  sigma_dem = 0.0001,
  S_0 = 20000, 
  I_0 = 100
)

# Generate pomp object
measles_pomp <- pomp(
  data = obs_data,
  time = "biweek",
  covar = covar_data,
  tcovar = "biweek",
  t0 = 1,
  rprocess = discrete.time.sim(measles_process, delta.t = 1),
  rmeasure = rmeas,
  dmeasure = dmeas,
  initializer = init,
  statenames = c("S", "I"),
  toEstimationScale = to_est,
  fromEstimationScale = from_est,
  paramnames = names(params),
  params = params,
  globals = "int K = 6;"
)
```

### Simulations from the model
We can use the `measles_pomp` object to simulate from the model given the parameters we fed into it.
This is a good check to make sure the model is OK.
We plot 9 simulations (red) along with the data (blue) below.

```{r simulation-test}
simulate(
  measles_pomp, 
  nsim = 9,
  as.data.frame = TRUE,
  include.data = TRUE) %>%
  ggplot(aes(x = time, y = cases, group = sim, color = (sim == "data"))) +
    geom_line() +
    scale_color_manual(values = c(`TRUE` = "blue", `FALSE` = "red"))+
    guides(color = FALSE) +
    facet_wrap(~sim, ncol = 2) +
    scale_y_sqrt() +
    theme(strip.text=element_blank())
```

Not bad.
Magnitudes are bit a off, but these are just random guess parameters.
Importantly, it appears the model is capable of reproducing the dynamics of the data.

It is also important to make sure the underlying likelihood model is specified properly.
We can test this by running one instance of the particle filter (`pomp::pfilter()`) at the current parameter values: `logLik(pfilter(measles_pomp, Np = 1000))` = `r round(logLik(pfilter(measles_pomp, Np = 1000)))`.
Note that at this stage we also receive the warning `in 'pfilter': 56 filtering failures occurred.`
This is OK at the moment because we are not using these parameters for inference.

## Maximization by Iterated particle Filtering
We now move to actually fitting the measles SIR model, using Maximization by Iterated particle Filter (MIF).
MIF varies parameters throughout the filtering process and selectively propogates parameter sets (``particles'') that have the highest likelihood given the data and model.
We use the `pomp::mif2()` function to perform a grid search over parameter space that lets us hone in on the maximum likelihood estimates (MLE) for each parameter.
We start with a global search, and the proceed to a localized search around the MLEs from the global search.

### Probe matching a la Wood 2010 (*Nature*)
First, we utilize probe matching to hone in on parameter values that result in model simulations with similar statistical properties as the observed data.
Here, we estimate parameters based on the synthetic likelihood (Wood 2010, *Nature*).
We used three statistics:
1. The number of weeks with zero reported cases.
2. The maximum number of reported cases over the entire time series.
3. The autocorrelation of cases at lag 1, which is a lag of 2 weeks in real time since we are dealing with biweekly data.

We use the parameter estimates from this step as starting points for the MIF.
 
```{r probe}
probe.zeroes <- function(y){
  xy <- y["cases",]
  as.numeric(length(which(xy == 0)))
}
probe.max <- function(y){
  max(y["cases",], na.rm = TRUE)
}
probe.cumsum <- function(y){
  cases <- y["cases",1:26]
  max(cumsum(cases))
}

# probe(measles_pomp, probes = list(probe.zeroes), nsim = 500)

plist <- list(
  probe.zeroes,
  probe.max,
  probe.cumsum,
  probe.acf("cases", lags = 1,transform = sqrt, type = "correlation")
)


stew(
  file = "probe_match_results.rda", {
    pm <- probe.match(
      measles_pomp,
      probes = plist,
      est = names(params),
      nsim = 500,
      transform = TRUE,
      start = params,
      method = "SANN",
      seed = 124925L,
      maxit = 10000
    )
  },
  seed = 290860832,
  kind = "L'Ecuyer"
)

pm_ll <- logLik(pfilter(measles_pomp, Np = 1000, params = coef(pm)))

simulate(
  measles_pomp, 
  params = coef(mf),
  nsim = 9,
  as.data.frame = TRUE,
  include.data = TRUE) %>%
  ggplot(aes(x = time, y = cases, group = sim, color = (sim == "data"))) +
    geom_line() +
    scale_color_manual(values = c(`TRUE` = "blue", `FALSE` = "red"))+
    guides(color = FALSE) +
    facet_wrap(~sim, ncol = 2) +
    scale_y_sqrt() +
    theme(strip.text=element_blank())
```

The log-likelihood at these parameter values is `r pm_ll`.

### Global search

```{r global-mif}
# Define parameter search space based on probe.match results
# param_box <- rbind(
#   beta_mu = c(0.0000001, 0.0001),
#   b1 = c(-5, 5),
#   b2 = c(-5, 5),
#   b3 = c(-5, 5),
#   b4 = c(-5, 5),
#   b5 = c(-5, 5),
#   b6 = c(-5, 5),
#   rho = c(0.3, 0.7),
#   tau = c(0.00001, 0.2),
#   S_0 = c(10000, 50000),
#   I_0 = c(5, 100),
#   psi = c(0, 10)
# )

probe_ests <- coef(pm)

make_guess <- function(params, sd_perc = 0.1){
  n <- length(params)
  out <- numeric(n)
  for(i in 1:n){
    out[i] <- rnorm(1, params[i], abs(params[i])*sd_perc)
  }
  names(out) <- names(params)
  return(out)
}

stew(file="global_search_measles.rda",{
  w1 <- getDoParWorkers()
  t1 <- system.time({
    m1 <- foreach(i=1:2,.packages='pomp',.combine=rbind,
                  .options.multicore=list(set.seed=TRUE)
    ) %dopar% {
      guess <- make_guess(probe_ests, sd_perc = 0.2)
      mf <- mif2(measles_pomp,
                 start=c(guess),
                 Np=2000,
                 Nmif=1000,
                 cooling.type="hyperbolic",
                 cooling.fraction.50=1,
                 transform=TRUE,
                 rw.sd=rw.sd(
                   beta_mu=0.02, rho=0.02, tau=0.02,
                   b1 = 0.02, b2 = 0.02, b3 = 0.02, b4 = 0.02, b5 = 0.02, b6 = 0.02,
                   I_0=ivp(0.2), S_0=ivp(0.2), psi = 0.02
                 )
                )
      ll <- logmeanexp(replicate(10,logLik(pfilter(mf,Np=5000))),se=TRUE)
      data.frame(as.list(coef(mf)),loglik=ll[1],loglik.se=ll[2])
    }
  })
},seed=290860873,kind="L'Ecuyer")

m1
```





