---
title: "Bayesian state-space SI model with year-specific, smooth seasonality"
author: "Andrew Tredennick"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, fig.height = 4)

library(tidyverse)  # data wrangling
library(lubridate)  # time and date functions
library(ggthemes)   # pleasing ggplot2 themes
library(rjags)      # Gibbs & Metroplis MCMC sampling algorithm for Bayesian models
library(ggmcmc)     # quick conversions of MCMC output to data frames
library(splines)    # generating basis functions
library(mgcv)       # fitting generalized additive models
library(viridis)    # pleasing color palette
library(spaero)     # project AERO code; EWS metrics, etc.

theme_set(theme_minimal())  # set ggplot2 theme globally
```

## The model
The idea is to fit a discrete-time state-space model following susceptible-infected (SI) dynamics.
Previous TSIR (time-series SIR) models allowed for seasonality in transmission rate, but that seasonality was shared among all years.
This creates problems when attempting to calculating time-varying quantities of interest, such as effective reproductive rate ($R_e(t)$).
Here, I will implement a more flexible approach, where seasonality is incorporated with a smooth basis function (spline) that has year-specific parameters.

The model is as follows:

$$
y_t \sim \text{Negative Binomial}(\rho I_t, \eta) \\
\lambda_t = e^{-\beta_t (I_t + \psi)} \\
\Delta_t \sim \text{Binomial}(\lambda_t, S_t) \\
I_{t+1} = S_t - \Delta_t, \\
S_{t+1} = b_t + \Delta_t,\\
\beta_t = \gamma_t \left[1 + \upsilon\;\text{sin}\left(\frac{2 \pi t}{26} + \theta \right) \right] , \\
\gamma_t = \gamma_0 + t\;\text{log}(1-r) + \varepsilon_t, \\
\varepsilon_t \sim \text{Normal}(0,\sigma^2)
$$

| Parameter | Definition | 
| --------- | ----------------------------------|
| $I_t$ | Number of infected individuals at time *t* (latent). |
| $S_t$ | Number of susceptible individuals at time *t* (latent). |
| $y_t$ | Number of reported cases at time *t* (observed). |
| $\rho$ | Reporting fraction. |
| $b_t$ | Number of births at time *t*. |
| $\lambda_t$ | Probability of escaping infection at time *t*. |
| $\Delta_t$ | Number of susceptibles that escape infection at *t*. |
| $\beta_t$ | Seasonally forced transmission rate at time *t*. |
| $\gamma_t$ | Transmission rate at time *t*. |
| $\gamma_0$ | Initial T transmission rate at time 0. |
| $\upsilon$ | Amplitude of sin wave. |
| $\theta$ | Phase of sin wave. |
| $\varepsilon_t$ | Noise on transmission rate at time *t*. |
| $\sigma^2$ | Variance of noise term for transmission rate. |

## Fitting the model
I will use a subset of the Niger measles data that come from the capitol, Niamey.

```{r load-data}
file_name <- "../niger_measles/niger_regional_1995_2005.csv"
niger_measles_raw <- read_csv(file_name, col_types = cols())

num_regions <- nrow(niger_measles_raw)
num_weeks <- ncol(niger_measles_raw) - 1  # subtract 1 from ncol() because first column are regions
weeks_per_year <- num_weeks/11
weeks <- rep(1:52, times = 11)

# Create a vector of years for all num_weeks
years <- rep(1995:2005, each = weeks_per_year)

# Function for calculating start of week based on week number and year
calculate_start_of_week = function(week, year) {
  date <- ymd(paste(year, 1, 1, sep="-"))
  week(date) = week
  return(date)
}

# Clean up the data frame
measles_data <- niger_measles_raw %>%
  gather(key = week, value = cases, -X1) %>%
  mutate(
    week_num = rep(1:num_weeks, each = num_regions),
    year = rep(years, each  = num_regions),
    week = rep(weeks, each = num_regions),
    date = calculate_start_of_week(week, year)
  ) %>%
  dplyr::rename(region = X1) %>%
  filter(region == "Niamey (City)")

# Plot the time series
ggplot(measles_data, aes(x = date)) +
  geom_ribbon(aes(ymax = cases, ymin = 0), fill = "grey35") +
  labs(x = "Date", y = "Reported cases") +
  ggtitle("Reported cases of measles", subtitle = "Niamey, Niger")
```

I will fit the model using a Bayesian state-space approach, implemented in JAGS.

```{r ferrari-results, include=FALSE, eval=FALSE}
# These are the posterior estimates/draws from the TSIR model fit 
# in Ferrari et al. 2008.
source("./ferrari_results_2008/niamey_new_1.q")

si_states <- tibble(
  susceptibles = res[[1]],
  infecteds = res[[2]],
  week_num = 1:length(res[[2]])
) %>%
  gather(key = state, value = number, -week_num)

ggplot(si_states, aes(x = week_num, y = number))+
  geom_line() +
  facet_wrap(~state, scales = "free_y")

mean_susceptibles <- mean(res[[1]])
sd_susceptibles <- sd(res[[1]])

n <- length(res[["P"]])
prior <- rbeta(n, 3.6, 6.3)
P <- res[["P"]]
plot_p <- tibble(
  iteration = 1:n,
  post = P,
  prior = prior
) %>%
  gather(key = dist, value = value, -iteration)

ggplot(plot_p, aes(x = value)) +
  geom_histogram(aes(fill = dist)) +
  scale_fill_manual(values = c("red", "grey"), labels = c("Posterior", "Prior"), name = NULL) +
  geom_vline(aes(xintercept = 0.48), color = "blue") +
  annotate(geom = "text", x = 0.65, y = 8100, 
           label = "Posterior mean from\nFerrari et al. 2008", color = "blue") +
  annotate(geom = "text", x = 0.25, y = 5100, 
           label = "Posterior in\nres list", color = "red") +
    annotate(geom = "text", x = 0.75, y = 1000, 
           label = "Prior from\nFerrari et al. 2008", color = "black") +
  guides(fill = FALSE) +
  labs(x = expression(P[obs.]), y = "Frequency")


```

### JAGS Model
```{r jags-model, eval = FALSE, echo=FALSE}
measles_model <- "
model{
  # Likelihood/Data Model
  for(i in 1:nobs){
    # y[i] ~ dpois(rho*I[i])
    y[i] ~ dlnorm(max(0.000001, log(rho*I[i])), tau)
  }
  tau = pow(sigma, -2)
  sigma ~ dunif(0, 100)
  
  # Process model
  for(t in 1:(ntimes-1)){
    lambda[t] = beta[t] * S[t] * (I[t] + 0.01)
    dI[t] ~ dpois(lambda[t])
    I[t+1] = dI[t] + 0.0000001
    S[t+1] = bs[t] + S[t] - (dI[t] + 0.0000001)
  }

  # Parameter model
  for(t in 1:(ntimes-1)){
    beta[t] = gamma[t] * (1 + epsilon * sin( (2*pi*t)/26 + theta ) )
    bs[t] ~ dpois(b[t])
  }
  for(t in 2:ntimes){
    gamma[t] ~ dnorm(gamma[t-1], tau_gamma)
  }
  
  gamma[1] ~ dnorm(mean_gamma, tau_gamma)
  mean_gamma ~ dgamma(1, 1000)
  epsilon ~ dunif(0, 1)
  theta ~ dunif(1, 3)
  rho ~ dbeta(3.6, 6.3)
  tau_gamma = pow(sigma_gamma, -2)
  sigma_gamma ~ dunif(0, 100)

  # Initial conditions
  S0 ~ dunif(1000, 100000)
  S[1] = S0
  I[1] ~ dnorm(initI, 0.001)

  # Derived quantity
  for(i in 1:nobs){
    Iobs[i] = I[i]*rho 
  }
}
"
```

```{r jags-model2}
measles_model <- "
model{
  # Likelihood/Data Model
  for(i in 1:nobs){
    p[i] <- r/(r + rho*I[i])
    y[i] ~ dnegbin(p[i], r)
  }
  r ~ dunif(0, 50)
  
  # Process model
  for(t in 1:(ntimes-1)){
    escape_prob[t] = exp(-beta[t] * (I[t] + m))
    # escape_prob[t] = (1 + (beta[t] * (I[t] + m)) / kappa)^(-kappa)
    escapees[t] ~ dbin(escape_prob[t], S[t])
    I[t+1] = max(0.000001, S[t] - escapees[t])
    S[t+1] = b[t] + escapees[t]
  }
  # kappa ~ dunif(0, 50)
  m ~ dunif(0, 100)

  # Parameter model
  for(t in 1:(ntimes-1)){
    beta[t] = exp(gamma[t]) * (1 + epsilon * sin( (2*pi*t)/26 + theta ) )
  }
  for(t in 2:ntimes){
    noise[t] ~ dnorm(0, tau_gamma)
    # gamma[t] = psi*gamma[t-1] + psi2*noise[t]
    gamma[t] = gamma0 + t * log(1+rg) + noise[t]
  }

  noise[1] ~ dnorm(0, tau_gamma)
  # gamma[1] = psi*gamma0 + psi2*noise[1]
  gamma[1] = gamma0 + 1 * log(1+rg) + noise[1]
  # gamma[1] = intercept + base * gamma0 + noise[1]
  gamma0 ~ dunif(-20, -9)  # prior ranging from Re = 1 to Re = 25
  tau_gamma = pow(sigma_gamma, -2)
  sigma_gamma ~ dunif(0, 1)
  # psi ~ dunif(0.8, 1.3)  # slightly weird range b/c AR(1) is on log scale now
  # psi2 ~ dunif(0,1)
  # intercept ~ dunif(-10, -2)
  # base ~ dunif(0,1)
  rg ~ dunif(-0.2, 0.2)

  epsilon ~ dunif(0, 1)
  theta ~ dunif(0, 26)
  rho ~ dbeta(3.6, 6.3)

  # Initial conditions
  S0 ~ dunif(50000, 400000)
  S02 ~ dpois(S0)
  S[1] <- S02
  I0 ~ dpois(initI/rho)
  I[1] = I0

  # Derived quantities
  for(i in 1:nobs){
    Iobs[i] = I[i]*rho 
    Rnaught[i] = exp(gamma[i]) #*N[i]
  }
}
"
```


### Set up data for JAGS
```{r setup-jagas}
# Read in population data and estimate births
population <- read_csv("../niger_measles/district_pops.csv") %>%
  gather(key = year, value = population, -X1) %>%
  rename(district = X1) %>%
  filter(district == "Niamey I")

birth_rates <- read_csv("../niger_measles/niger_crude_birth_rates.csv") %>%
  mutate(
    date = mdy(date),  # lubridate prefixes any 2digit year 00-68 with 20, not a problem for us though
    year = as.character(year(date)),
    rate_per_person = births_per_thousand/1000
  ) %>%
  select(year, rate_per_person)

births <- population %>%
  left_join(birth_rates, by = "year") %>%
  mutate(
    births_per_year = population * rate_per_person,
    births_per_week = births_per_year / 52
  )

# Aggregate weekly data to biweeks
biweek_data <- measles_data %>%
  mutate(biweek = rep(1:(n()/2), each = 2)) %>%
  group_by(biweek) %>%
  summarise(
    cases = sum(cases),
    date = min(date)
  ) %>%
  mutate(
    births = round(rep(births$births_per_week*2, each = 26)),
    population = round(rep(population$population, each = 26))
  ) %>%
  filter(year(date) < 2001)
  

# Gather data
y <- biweek_data$cases
# y[y<1] <- NA
initI <- biweek_data$cases[1]
b <- biweek_data$births
ntimes <- nrow(biweek_data)
nobs <- nrow(biweek_data)
```

### Run the MCMC via JAGS
```{r run-jags, eval = FALSE}
# List up data for JAGS
jags_data <- list(
  y = y,
  initI = initI,
  b = b,
  ntimes = ntimes,
  nobs = nobs,
  pi = pi,
  N = biweek_data$population
)

# Initialize model in JAGS
model <- jags.model(
  textConnection(measles_model),
  data = jags_data,
  n.chains = 1,
  n.adapt = 20000
)

update(model, n.iter = 20000)

mcmc_results <- coda.samples(
  model,
  variable.names = c("Iobs", "I", "S", "Rnaught", "gamma", "beta", "rho", "escape_prob", "psi", "psi2", "theta", "r", "sigma_gamma","epsilon", "S02", "I0", "gamma0", "m", "rg"),
  n.iter = 20000,
  n.thin = 1
)

mcmc_tbl <- ggs(mcmc_results) %>%
  group_by(Parameter) %>%
  summarise(
    median_value = median(value),
    upper_95 = quantile(value, 0.975),
    lower_95 = quantile(value, 0.025),
    upper_50 = quantile(value, 0.75),
    lower_50 = quantile(value, 0.25)
  )
# write_csv(mcmc_tbl, path = "./mcmc_results.csv")
```

### Summarize posterior samples and plot results

```{r summarize-plot}
mcmc_tbl <- read_csv("./mcmc_results.csv")

time_invariants <- mcmc_tbl %>%
  filter(!grepl("\\[", Parameter))
knitr::kable(time_invariants)

escape_probs <- mcmc_tbl %>%
  filter(grepl("escape_prob", Parameter))

model_observations <- mcmc_tbl %>%
  filter(grepl("Iobs\\[", Parameter)) %>%
  mutate(
    observed_cases = biweek_data$cases,
    date = biweek_data$date
  )

model_latents <- mcmc_tbl %>%
  filter(grepl("I\\[", Parameter) | grepl("S\\[", Parameter)) %>%
  mutate(
    date = rep(biweek_data$date, times = 2)
  ) %>%
  separate(Parameter, into = c("param_family", "trash"), sep ="\\[") %>%
  select(-trash) %>%
  mutate(
    param_name = ifelse(param_family == "S", "Susceptible", "Infectious")
  )

transmission_rate <- mcmc_tbl %>%
  filter(grepl("Rnaught\\[", Parameter)) %>%
  mutate(
    date = biweek_data$date
  )

mycolors <- c("coral","steelblue")
obscomp <- ggplot(model_observations, aes(x = date)) +
  geom_point(aes(y = observed_cases), shape = 1, color = "grey45", size = 0.75) +
  geom_ribbon(aes(ymin = lower_95, ymax = upper_95), alpha = 0.15, fill = mycolors[1]) +
  geom_ribbon(aes(ymin = lower_50, ymax = upper_50), alpha = 0.35, fill = mycolors[1]) +
  geom_line(aes(y = median_value), color = mycolors[1], linetype = 2) +
  labs(x = "Date", y = "Number of reported cases") +
  # scale_y_continuous(trans = "log") +
  NULL

post_rho <- time_invariants %>%
  filter(Parameter == "rho") %>%
  pull(median_value) %>%
  round(2)

latents <- ggplot(model_latents, aes(x = date, y = median_value)) +
  geom_ribbon(aes(ymin = lower_95, ymax = upper_95, fill = param_name), alpha = 0.15) +
  geom_ribbon(aes(ymin = lower_50, ymax = upper_50, fill = param_name), alpha = 0.35) +
  geom_line(aes(color = param_name), linetype = 2) +
  facet_wrap(~param_name, scales = "free_y", ncol = 1) +
  scale_color_manual(values = mycolors) +
  scale_fill_manual(values = mycolors) +
  guides(color = FALSE, fill = FALSE) +
  labs(x = "Date", y = "Number of persons") +
  ggtitle(bquote(rho~"="~.(post_rho))) +
  theme(plot.title = element_text(size = 8)) +
  # scale_y_continuous(trans = "log") +
  NULL

gamma <- ggplot(transmission_rate, aes(x = date, y = median_value)) +
  geom_ribbon(aes(ymin = lower_95, ymax = upper_95), alpha = 0.15) +
  geom_ribbon(aes(ymin = lower_50, ymax = upper_50), alpha = 0.35) +
  geom_line(linetype = 2, color = "grey45") +
  labs(x = "Date", y = expression(R[e])) +
  # scale_y_continuous(trans = "log") +
  NULL

grid1 <- cowplot::plot_grid(obscomp, gamma, ncol = 1, align = "v")
grid2 <- cowplot::plot_grid(grid1, latents, ncol = 2)
grid2

one_to_one_scatter <- ggplot(model_observations, aes(x = log10(observed_cases+1), y = log10(median_value+1))) +
  geom_point(size = 3, alpha = 0.5) +
  geom_abline(aes(intercept = 0, slope = 1), linetype = 2) +
  xlab(expression(paste("Observed ", log[10], "(cases + 1)"))) +
  ylab(expression(paste("Expected ", log[10], "(cases + 1)")))
one_to_one_scatter

```

```{r log-rw, eval=FALSE, include=FALSE}
rw <- function(times, x1, psi, psi2){
  x <- numeric(times)
  x[1] <- x1
  for(t in 2:times){
    x[t] <- x[t-1]*psi + psi2*rnorm(1,0,10)
  }
  return(exp(x))
}

psi <- 1.01
psi2 <- 0.0353

out <- rw(times = 100, x1 = log(0.00001), psi, psi2)
par(mfrow = c(2,1))
plot(out)
plot(log(out))

exp_func <- function(r, start_value, times){
  outs <- numeric(times)
  outs[1] <- start_value
  for(t in 2:times){
    outs[t] <- start_value + t * log(1+r) + rnorm(1,0,0.1)
  }
  return(outs)
} 


test <- exp_func(r = -0.01, start_value = -10, times = 50)

plot(exp(test))


```