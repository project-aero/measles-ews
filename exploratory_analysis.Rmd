---
title: "Exploratory analysis of measles data from China and Niger"
author: Andrew Tredennick
output: html_document
date: "`r format(Sys.time(), '%d %B, %Y')`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)  # data wrangling
library(lubridate)  # time and date functions
library(ggthemes)   # pleasing ggplot2 themes
library(codyn)      # community dynamics metrics (e.g., synchrony)
library(rjags)      # Gibbs MCMC sampling algorithm for Bayesian models
library(ggmcmc)     # quick conversions of MCMC output to data frames
library(mgcv)       # fitting generalized additive (spline) models
library(viridis)    # pleasing color palette
library(spaero)     # project AERO code; EWS metrics, etc.
```

## Niger data

### Fetch the Niger measles data

The data are stored as a matrix with rows for each of 40 regions and columns for the region name and incident numbers for each week starting 1 January 1995 for eleven years.

```{r fetch-niger-data, message=FALSE, warning=FALSE}
file_name <- "../niger_measles/niger_regional_1995_2005.csv"
niger_measles_raw <- read_csv(file_name, col_types = cols())

num_regions <- nrow(niger_measles_raw)
num_weeks <- ncol(niger_measles_raw) - 1  # subtract 1 from ncol() because first column are regions

# Create a vector of dates for each week over 11 years
start_date <- ymd("19950101")
all_dates <- seq(start_date, by = "week", length.out = num_weeks)

niger_measles <- niger_measles_raw %>%
  gather(key = week, value = cases, -X1) %>%
  mutate(
    week_num = rep(1:num_weeks, each = num_regions),
    date = rep(all_dates, each = num_regions)
  ) %>%
  dplyr::rename(region = X1) %>%
  dplyr::select(-week)

glimpse(niger_measles)
```

### Plot the time series by region

```{r plot-niger-measles, warning=FALSE}
ggplot(data = niger_measles, aes(x = date, y = cases)) +
  geom_line() +
  facet_wrap(~region, scales = "free_y") +
  theme_minimal(base_size = 9) +
  ggtitle("Measles cases in Niger", subtitle = "Weekly, by region")
```

### Calculate sychrony of cases across all regions
```{r calc-synch-niger}
regional_synchrony <- codyn::synchrony(
  df = niger_measles,
  time.var = "week_num", 
  species.var = "region", 
  abundance.var = "cases",
  metric = "Loreau"
  )
```

Synchrony of measles cases across all regions is `r round(regional_synchrony, 2)`. The synchrony metric ranges from 0 (perfectly asynchronous) to 1 (perfectly sunchronus).

Now look at all pairwise correlations.

```{r niger-corrs}
niger_cor_matrix <- niger_measles %>%
  spread(region, cases) %>%
  dplyr::select(-week_num, -date) %>%
  cor()

corrplot::corrplot(niger_cor_matrix, type="lower")
```

### Recreate Ferrari et al. 2010 Figure 1 (sort of)

```{r heatmap-cases}
niger_measles_0na <- niger_measles %>%
  mutate(
    cases = ifelse(cases == 0, NA, cases)
  )
ggplot(niger_measles_0na, aes(x = date, y = region, fill = log(cases))) +
  geom_tile() +
  scale_fill_viridis() +
  theme_minimal()
```

### Plot just Niamey
```{r plot-niamey-measles}
ggplot(data = filter(niger_measles, region == "Niamey (City)"), aes(x = date, y = cases)) +
  geom_point() +
  theme_minimal(base_size = 15) +
  ggtitle("Measles cases in Niamey, Niger", subtitle = "Weekly")
```

### Attempt to fit a TSIR model to Niamey data
I am trying to fit a model like the one presented [Ferrari et al. 2008](https://www.nature.com/articles/nature06509). The structure of the model is:

\begin{align} 
\textbf{Process:} \quad \lambda_t &= \beta_m S_t I_t^\alpha \\
I_{t+1} &\sim \text{Negative Binomial}\left(\lambda_t, I_t \right), \\
S_{t+1} &= S_t - I_{t+1} + B_t, \\
S_{t=0} &\sim \text{Normal}(x, \sigma^2). \\
\textbf{Data:} \quad y_m &\sim \text{Binomial}\left(I_m, p_{\text{obs}} \right), 
\end{align}

where parameters are as follows:

+ $\lambda_t$: epidemic intensity at time *t*
+ $\beta_m$: tranmission rate in month *m*
+ $S_t$: size of latent susceptible population at time *t*
+ $I_t$: size of latent infected population at time *t*
+ $\alpha$: parameter for nonlinear transmission (if present)
+ $B_t$: birthrate at time *t*, assumed to be constant and discounted by 70% vaccination rate
+ $p_{\text{obs}}$: reporting rate

### Reconstruct the susceptible class
Following: https://rss.onlinelibrary.wiley.com/doi/epdf/10.1111/1467-9876.00187 and description from https://esajournals.onlinelibrary.wiley.com/doi/epdf/10.1890/0012-9615%282002%29072%5B0169%3ADOMEES%5D2.0.CO%3B2

> We, therefore, carry out susceptible reconstruction using the algorithm proposed by Finkenstadt and Grenfell (2000). In summary, this method reconstructs the dynamics of the unobserved susceptible class from data on births and reported cases. The size of the susceptible class reﬂects a balance between the rate of loss of passive maternal immunity of infants (assumed to occur at 4 mo) and the recovery rate of recently infected individuals (who have active immunity henceforth).The susceptible reconstruction is achieved by regressing cumulative births against cumulative case notiﬁcations (see Finkenstadt and Grenfell 2000 for details).The residuals from this regression represent the cyclical deviation of the susceptible class around the mean number of susceptibles, S, as driven by the epidemic dynamics. We denote the deviations by zt.The only assumption necessary to make for this to work is that the reporting rate is constant through time. Since the 1944–1966 period showed signiﬁcant changes in public health and socioeconomic patterns, it makes sense to allow for the possibility of smooth changes in reporting rates. We do this by using a locally linear regression of the cumulative–cumulative plot (Finkenstadt and Grenfell 2000).

```{r susc-recon}
niamey_pop <- tibble(
  year = c(2001, 2012),
  population = c(707951, 1026800)  # from UN DATA, via Google
)

poptrend <- lm(population~year, data = niamey_pop)
poppreds <- round(predict(poptrend, newdata = data.frame(year = 1995:2005)))

niamey_pop_preds <- tibble(
  year = 1995:2005,
  population = poppreds
)

# Define biweeks and match up to weeks
first_week <- min(niger_measles$date)+7  # add 7 days to get first biweek
last_week <- max(niger_measles$date)
biweeks <- seq(first_week, last_week, "2 weeks")
if(max(biweeks) != last_week) stop("Biweeks not matching up.")

week_match <- tibble(
  date = unique(niger_measles$date),
  biweek = rep(biweeks, each = 2)
)

niamey_biweekly <- niger_measles %>%
  filter(region == "Niamey (City)") %>%
  left_join(week_match, by = "date") %>%
  group_by(biweek) %>%
  summarise(cases = sum(cases)) %>%
  mutate(cumcases = cumsum(cases)) %>%
  mutate(
    year = year(biweek)
  ) %>%
  left_join(niamey_pop_preds, by = "year") %>%
  mutate(
    yrly_birth_rate = (50.73/1000) * 0.7,
    biweek_birth_rate = yrly_birth_rate/26,
    births = round(population*biweek_birth_rate)
  ) %>%
  mutate(
    cumbirths = cumsum(births)
  )

zt <- resid(gam(cumbirths ~ s(cumcases), data = niamey_biweekly))

susceptible_deviations <- tibble(
  biweek = niamey_biweekly$biweek,
  zt = zt
)

ggplot(susceptible_deviations, aes(x = biweek, y = zt)) +
  geom_point() +
  labs(x = "Date", y = "Deviation from mean susceptible size (z)")+
  theme_minimal() +
  ggtitle("Reconstructed susceptible dynamics")

```


First define the JAGS model.

```{r niger-jags}
tsir_jags_model <- "
model{
  # Latent process
  for(t in 1:(weeks-1)){
    I[t+1] <- log(beta[wid[t]]) + alpha*log(y[t]) + eps*z[t]  # epidemic intensity
    # p[t] <- I[t]/(I[t]+lambda[t]) 
    # I[t+1] ~ dnegbin(p[t], I[t])

    # S[t+1] <- eps*z[t] - I[t+1] + B[t]  # new susceptibles
  }
  
  # Observation process
  for(t in 1:weeks){
    #y[t] ~ dbin(p_obs, I[t])  # binomial likelihood
    y[t] ~ dnorm(exp(I[t]), tau)
  }

  # Priors
  #Sbar ~ dunif(minsize, 1000000)  # initial pool of susceptibles
  #S[1] <- eps*z[1]
  I[1] <- 3
  tau ~ dunif(0.0001, 10)
  p_obs ~ dbeta(3.6, 6.3)  # from Ferrari et al. 2008
  alpha ~ dbeta(100, 5)  # from Ferrari et al. 2008
  eps ~ dnorm(0,0.001)
  for(t in 1:biweeksyear){
    beta[t] ~ dbeta(0.8, 1000)  # from Ferrari et al. 2008
  }
}
"
```

Aggregate data to biweekly cases to match measles timescale (2 weeks from infection to recovery) and set up JAGS inputs.

```{r niger-jags-setup}
# ggplot(niamey_biweekly, aes(x = biweek, y = cases)) +
#   geom_point() +
#   labs(x = "Date", y = "Reported cases") +
#   theme_minimal(base_size = 15) +
#   ggtitle("Bi-weekly measles cases", subtitle = "Niamey, Niger")

# Set up data for JAGS
niamey_jags <- niamey_biweekly %>%
  left_join(susceptible_deviations, by = "biweek")

y <- pull(niamey_jags, cases)
z <- pull(niamey_jags, zt)
B <- pull(niamey_jags, births)
weeks <- length(y)
n_years <- length(unique(year(niamey_jags$biweek)))
biweeksyear <- weeks/n_years
wid <- rep(1:biweeksyear, times = n_years)

if(
  length(z) != length(y) |
  length(z) != length(B) |
  length(y) != length(B)
) { stop("Observation vectors are not of equal length.") }

jags_data <- list(
  y = y,
  z = z,
  weeks = weeks,
  B = B,
  minsize = round(0-min(zt)),
  biweeksyear = biweeksyear,
  wid = wid
)

# model <- jags.model(
#   textConnection(tsir_jags_model),
#   data = jags_data,
#   n.chains = 1,
#   n.adapt = 2000
# )
# 
# mcmc_results <- coda.samples(model, variable.names = c("I"), n.iter = 5000)
# mcmc_df <- ggs(mcmc_results) %>%
#   group_by(Parameter) %>%
#   summarise(mean_value = mean(value),
#             upper_value = quantile(value, 0.9),
#             lower_value = quantile(value, 0.1)) %>%
#   mutate(biweek = 1:26)
# 
# ggplot(mcmc_df, aes(x = biweek, y = mean_value)) +
#   geom_ribbon(aes(ymax = upper_value, ymin = lower_value), alpha = 0.5, fill = "grey") +
#   geom_line() +
#   theme_minimal()
```


### Clark and Bjornstadt TSIR model

I just can't seem to get the Ferrari style model working, so I am going to use the Clark version (https://esajournals.onlinelibrary.wiley.com/doi/10.1890/03-0520), which still uses the susceptible reconstrunction, in a way. Note that I now must rely on the interpolated population estimates and number of biweekly births from above. Might be able to amend that once it is up and running.

```{r clark-tsir-jags}
clark_tsir <- "
 model{
  # Process model
  for(t in 2:timesteps){
   theta[t-1] <- beta[wid[t-1]] * I[t-1] / N[t-1]
   I[t] ~ dbin(theta[t-1], S[t-1])
   S[t] <- S[t-1] + B[t-1] - I[t]
  }

  # Data model
  for(i in 1:nobs){
   y[i] ~ dbin(rho, I[i])
  }

  # Parameter model
  I[1] <- 43
  S[1] <- 120000
  rho ~ dbeta(10,60)
  for(w in 1:26){
   beta[w] ~ dunif(0, 20)
  }
 }
"

niamey_jags <- niamey_biweekly 

weeks <- nrow(niamey_jags)
n_years <- length(unique(year(niamey_jags$biweek)))
biweeksyear <- weeks/n_years
wid <- rep(1:biweeksyear, times = n_years)
y <- niamey_jags$cases

# jags_data <- list(
#   N = niamey_jags$population,
#   B = niamey_jags$births,
#   y = y,
#   nobs = nrow(niamey_jags),
#   timesteps = nrow(niamey_jags),
#   wid = wid
# )
# 
# model <- jags.model(
#   textConnection(clark_tsir),
#   data = jags_data,
#   n.chains = 1,
#   n.adapt = 2000
# )

# mcmc_results <- coda.samples(model, variable.names = c("I"), n.iter = 5000)

```

### tsiR package attempt

I think my Bayesian attempts are failing because I just don't have the right model structure, and it's going to take more time to figure it all out -- though I think the Clark approach *should* work if we can get birth rates correct. In the meantime, I am going to try the `tsiR` package (http://journals.plos.org/plosone/article?id=10.1371/journal.pone.0185528). I don't think it is great for estimating states with fully specified uncertainty, but I should be able to get out time-varying SIR parameters.

```{r tsir}
library(tsiR)

# Set up data for tsiR
tsir_data <- niamey_biweekly %>%
  dplyr::select(biweek, cases, population, births) %>%
  dplyr::rename(
    time = biweek,
    pop = population
  ) %>%
  dplyr::select(time, cases, births, pop)

# tsir_results <- runtsir(
#   data = tsir_data, 
#   IP = 2, 
#   xreg = "cumcases", 
#   regtype = "loess", 
#   alpha = NULL, 
#   sbar = NULL, 
#   family = "gaussian", 
#   link = "identity", 
#   method = "negbin", 
#   nsim = 100)

# Estimate parameters
tsir_params <- estpars(
  data = tsir_data, 
  IP = 2, 
  xreg = "cumcases", 
  regtype = "loess", 
  alpha = NULL, 
  sbar = NULL, 
  family = "quasipoisson", 
  link = "log")

# plotbreaks(data = tsir_data, threshold = 20)

tsir_sim <- simulatetsir(
  data = tsir_data,
  IP = 2,
  parms = tsir_params,
  epidemics = "break",
  threshold = 3,
  method = "pois",
  nsim = 100)

plotforward(tsir_sim)

# Plot the time-varying transmission coefficient
beta_est <- tsir_params$contact

scale_factor <- 10^4
ggplot(beta_est, aes(x = time, y = beta*scale_factor)) +
  geom_ribbon(aes(ymax = betahigh*scale_factor, ymin = betalow*scale_factor), alpha = 0.5, fill = "grey", color = NA) +
  geom_line(color = "black") +
  geom_point(color = "black", size = 2) +
  labs(x = "Two-week period", y = expression(paste(beta[w], " (x1000)"))) +
  theme_minimal() +
  ggtitle("Biweekly measles transmission coefficients", subtitle = "Niamey, Niger")
```

Based on the biweekly estimates of transmission ($\beta$), I can calculate the time-varying force of infection, following Clark and Bjornstad (2004) as

$$
\phi_t = \beta_w \times \frac{I_t}{N_t}.
$$

I am going to use estimates from the `tsiR` simulations, $\hat{I}$, because these account for the estimated reporting rate ($\rho=$`r round(mean(1/tsir_params$rho),2)`). Note that the estimated reporting rate corresponds well with those reported in Ferrari papers using these data, which is encouraging.

```{r tsir-force}
infection_force <- niamey_biweekly %>%
  dplyr::select(biweek, population) %>%
  mutate(
    I_hat = tsir_sim$res$mean,
    beta = rep(beta_est$beta, times = n_years),
    force = beta * (I_hat/population)
  )

ggplot(infection_force, aes(x = biweek, y = log(force))) +
  geom_line()

```

# Early warning signals -- for all data
Look at early warning signals for each region separately.

```{r ews}
# Test with Niamey
niamey_cases <- niger_measles %>%
  filter(region == "Niamey (City)") %>%
  pull(cases)

ews_niamey <- spaero::get_stats(
  x = niamey_cases, 
  center_kernel="uniform",
  center_trend="local_constant", 
  center_bandwidth=10,
  stat_bandwidth=10
)

par(mfrow = c(2,1))
plot(ews_niamey$stats$variance_first_diff[300:350], type = "l")
abline(h = 0)
plot(niamey_cases[300:350])

# Shuffle the time series and recalculate, many times

out_var <- {}
for(i in 1:100){
  shuffled <- sample(niamey_cases, size = length(niamey_cases), replace = FALSE)
  ews_shuffled <- spaero::get_stats(
    x = shuffled, 
    center_kernel="uniform",
    center_trend="local_constant", 
    center_bandwidth=10,
    stat_bandwidth=10
  )
  out_var <- rbind(out_var, ews_shuffled$stats$variance_first_diff)
}
```