
R version 3.4.4 (2018-03-15) -- "Someone to Lean On"
Copyright (C) 2018 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> # fit_measles_state_space.R:
> #  R script to fit a Bayesian state space model to the measles case data from
> #  Niamey, Niger from 1995-2005. This script fits the specified model using
> #  MCMC via JAGS. The posterior distributions are summarized and saved. 
> #  NOTE: Full MCMC output is NOT saved currently, as this is a development
> #  script.
> #
> # Authors:
> #  Andrew Tredennick (atredenn@gmail.com)
> #  Pejman Rohani
> 
> 
> # Load libraries ----------------------------------------------------------
> 
> library(tidyverse)  # data wrangling
── Attaching packages ─────────────────────────────────────── tidyverse 1.2.1 ──
✔ ggplot2 3.0.0     ✔ purrr   0.2.5
✔ tibble  1.4.2     ✔ dplyr   0.7.4
✔ tidyr   0.8.1     ✔ stringr 1.3.1
✔ readr   1.1.1     ✔ forcats 0.3.0
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
> library(lubridate)  # time and date functions

Attaching package: ‘lubridate’

The following object is masked from ‘package:base’:

    date

> library(rjags)      # MCMC sampling algorithms for Bayesian models
Loading required package: coda
Linked to JAGS 4.3.0
Loaded modules: basemod,bugs
> library(ggmcmc)     # quick conversions of MCMC output to data frames
> library(parallel)   # functions for parallel computing on multiple cores
> library(pomp)       # functions for generating basis functions
> 
> 
> # Read in data ------------------------------------------------------------
> 
> file_name <- "niger_regional_1995_2005.csv"
> niger_measles_raw <- read_csv(file_name, col_types = cols())
Warning messages:
1: Missing column names filled in: 'X1' [1], 'X2' [2], 'X3' [3], 'X4' [4], 'X5' [5], 'X6' [6], 'X7' [7], 'X8' [8], 'X9' [9], 'X10' [10], 'X11' [11], 'X12' [12], 'X13' [13], 'X14' [14], 'X15' [15], 'X16' [16], 'X17' [17], 'X18' [18], 'X19' [19], 'X20' [20], 'X21' [21], 'X22' [22], 'X23' [23], 'X24' [24], 'X25' [25], 'X26' [26], 'X27' [27], 'X28' [28], 'X29' [29], 'X30' [30], 'X31' [31], 'X32' [32], 'X33' [33], 'X34' [34], 'X35' [35], 'X36' [36], 'X37' [37], 'X38' [38], 'X39' [39], 'X40' [40], 'X41' [41], 'X42' [42], 'X43' [43], 'X44' [44], 'X45' [45], 'X46' [46], 'X47' [47], 'X48' [48], 'X49' [49], 'X50' [50], 'X51' [51], 'X52' [52], 'X53' [53], 'X54' [54], 'X55' [55], 'X56' [56], 'X57' [57], 'X58' [58], 'X59' [59], 'X60' [60], 'X61' [61], 'X62' [62], 'X63' [63], 'X64' [64], 'X65' [65], 'X66' [66], 'X67' [67], 'X68' [68], 'X69' [69], 'X70' [70], 'X71' [71], 'X72' [72], 'X73' [73], 'X74' [74], 'X75' [75], 'X76' [76], 'X77' [77], 'X78' [78], 'X79' [79], 'X80' [80], 'X81' [81], 'X82' [82], 'X [... truncated] 
2: Duplicated column names deduplicated: 'V2' => 'V2_1' [366], 'V4' => 'V4_1' [367], 'V6' => 'V6_1' [368], 'V8' => 'V8_1' [369], 'V10' => 'V10_1' [370], 'V12' => 'V12_1' [371], 'V14' => 'V14_1' [372], 'V16' => 'V16_1' [373], 'V18' => 'V18_1' [374], 'V20' => 'V20_1' [375], 'V22' => 'V22_1' [376], 'V24' => 'V24_1' [377], 'V26' => 'V26_1' [378], 'V28' => 'V28_1' [379], 'V30' => 'V30_1' [380], 'V32' => 'V32_1' [381], 'V34' => 'V34_1' [382], 'V36' => 'V36_1' [383], 'V38' => 'V38_1' [384], 'V40' => 'V40_1' [385], 'V42' => 'V42_1' [386], 'V44' => 'V44_1' [387], 'V46' => 'V46_1' [388], 'V48' => 'V48_1' [389], 'V50' => 'V50_1' [390], 'V52' => 'V52_1' [391], 'V54' => 'V54_1' [392], 'V56' => 'V56_1' [393], 'V58' => 'V58_1' [394], 'V60' => 'V60_1' [395], 'V62' => 'V62_1' [396], 'V64' => 'V64_1' [397], 'V66' => 'V66_1' [398], 'V68' => 'V68_1' [399], 'V70' => 'V70_1' [400], 'V72' => 'V72_1' [401], 'V74' => 'V74_1' [402], 'V76' => 'V76_1' [403], 'V78' => 'V78_1' [404], 'V80' => 'V80_1' [405], 'V82' => ' [... truncated] 
> 
> num_regions <- nrow(niger_measles_raw)
> num_weeks <- ncol(niger_measles_raw) - 1  # subtract 1 from ncol() because first column are regions
> weeks_per_year <- num_weeks/11
> weeks <- rep(1:52, times = 11)
> 
> # Create a vector of years for all num_weeks
> years <- rep(1995:2005, each = weeks_per_year)
> 
> # Function for calculating start of week based on week number and year
> calculate_start_of_week = function(week, year) {
+   date <- ymd(paste(year, 1, 1, sep="-"))
+   week(date) = week
+   return(date)
+ }
> 
> # Clean up the data frame
> measles_data <- niger_measles_raw %>%
+   gather(key = week, value = cases, -X1) %>%
+   mutate(
+     week_num = rep(1:num_weeks, each = num_regions),
+     year = rep(years, each  = num_regions),
+     week = rep(weeks, each = num_regions),
+     date = calculate_start_of_week(week, year)
+   ) %>%
+   dplyr::rename(region = X1) %>%
+   filter(region == "Niamey (City)")
> 
> 
> # Specify the JAGS model --------------------------------------------------
> 
> measles_model <- "
+ model{
+   # Likelihood/Data Model
+   for(i in 1:nobs){
+     p[i] <- eta/(eta + (rho*I[i]))
+     y[i] ~ dnegbin(p[i], eta)
+   }
+   eta ~ dunif(0,50)
+   
+   # Process model
+   for(t in 1:(ntimes-1)){
+     inv_lambda[t] = exp(-beta[t] * (I[t] + psi))
+     Delta[t] ~ dbin(inv_lambda[t], S[t])
+     I[t+1] = E[t]
+     E[t+1] = S[t] - Delta[t]
+     S[t+1] = b[t] + Delta[t]
+   }
+   psi ~ dunif(0, 50)
+   
+   # Parameter model
+   for(t in 1:(ntimes-1)){
+     varepsilon[t] ~ dgamma(sh, ra)
+     beta[t] = exp(beta_mu * (1 + season[s[t]]) + btrend*trend[t]) * varepsilon[t]
+   }
+   
+   sh <- pow(1,2) / pow(sigma_env,2)
+   ra <- 1/pow(sigma_env, 2)
+   sigma_env ~ dunif(0.001, 1)
+   
+   for(t in 1:nseas){
+     season[t] <- inprod(base[t,], alpha[])
+   }
+   
+   # b-splines
+   for(i in 1:J){
+     alpha[i] ~ dnorm(0, tau_bsplines)
+   }
+   tau_bsplines <- pow(sigma_bsplines, -2)
+   sigma_bsplines ~ dunif(0.00001, 10)
+   
+   rho ~ dbeta(3.6, 6.3)  # centered on 0.5
+   btrend ~ dnorm(0, 0.01)
+   beta_mu ~ dnorm(-12, 0.001)
+   
+   # Initial conditions
+   S0 ~ dunif(5000, 100000)
+   S[1] <- trunc(S0)
+   E0 ~ dunif(10, 1000)
+   E[1] <- trunc(E0)
+   I0 ~ dunif(10, 1000)
+   I[1] <- trunc(I0)
+   
+   # Derived quantities
+   for(i in 1:nobs){
+     Iobs[i] = I[i]*rho 
+   }
+   
+   for(s in 1:nseas){
+     beta_season[s] = exp(beta_mu * (1+season[s]))
+   }
+ 
+ }  # end of model
+ "
> 
> 
> # Format data for model fitting -------------------------------------------
> 
> population <- read_csv("district_pops.csv") %>%
+   gather(key = year, value = population, -X1) %>%
+   rename(district = X1) %>%
+   filter(district == "Niamey I")
Parsed with column specification:
cols(
  X1 = col_character(),
  `1995` = col_double(),
  `1996` = col_double(),
  `1997` = col_double(),
  `1998` = col_double(),
  `1999` = col_double(),
  `2000` = col_double(),
  `2001` = col_double(),
  `2002` = col_double(),
  `2003` = col_integer(),
  `2004` = col_double(),
  `2005` = col_double()
)
Warning message:
Missing column names filled in: 'X1' [1] 
> 
> birth_rates <- read_csv("niger_crude_birth_rates.csv") %>%
+   mutate(
+     date = mdy(date),  # lubridate prefixes any 2digit year 00-68 with 20, not a problem for us though
+     year = as.character(year(date)),
+     rate_per_person = births_per_thousand/1000
+   ) %>%
+   select(year, rate_per_person)
Parsed with column specification:
cols(
  date = col_character(),
  births_per_thousand = col_double()
)
> 
> births <- population %>%
+   left_join(birth_rates, by = "year") %>%
+   mutate(
+     births_per_year = population * rate_per_person,
+     births_per_week = births_per_year / 52
+   )
> 
> # Aggregate weekly data to biweeks
> # model_data <- measles_data %>%
> #   mutate(biweek = rep(1:(n()/2), each = 2)) %>%
> #   group_by(biweek) %>%
> #   summarise(
> #     cases = sum(cases),
> #     date = min(date)
> #   ) %>%
> #   mutate(
> #     births = round(rep(births$births_per_week*2, each = 26)),
> #     population = round(rep(population$population, each = 26))
> #   )
> 
> # Collate weekly data
> model_data <- measles_data %>%
+   mutate(
+     births = round(rep(births$births_per_week, each = 52)),
+     population = round(rep(population$population, each = 52))
+   )
> 
> 
> # Gather data
> y <- model_data$cases
> initI <- model_data$cases[1]
> b <- predict(smooth.spline(x=model_data$week_num, y=model_data$births), x=model_data$week_num)$y
> N <- predict(smooth.spline(x=model_data$week_num, y=model_data$population), x=model_data$week_num)$y
> ntimes <- nrow(model_data)
> nobs <- nrow(model_data)
> nseas <- 52
> s <- rep(1:nseas, 11)
> base <- periodic.bspline.basis(x = 1:nseas, nbasis = 6, degree = 3, period = nseas)
> trend <- model_data$week_num - mean(model_data$week_num)
> 
> 
> # Set up JAGS variables ---------------------------------------------------
> 
> # List up data for JAGS
> jags_data <- list(
+   y = y,
+   b = round(b),
+   # N = round(N),
+   trend = trend,
+   ntimes = ntimes,
+   nobs = nobs,
+   s = s,
+   nseas = nseas,
+   base = base,
+   J = 6
+ )
> 
> # Create initial value function for parallel MCMC
> generate_initial_values <- function(){
+   init_list <- list(
+     Iobs = rpois(nobs, 100),  # observed cases state vector
+     I = rpois(nobs, 100/0.5),  # latent infected class state vector
+     E = rpois(nobs, 100/0.5),  # latent exposed class state vector
+     S = rpois(nobs, 30000),  # latent susceptible class state vector
+     beta_mu = runif(nobs, -6, -2),  # mean transmission rate
+     beta = runif(nobs, exp(-15), exp(-9)),  # time-varying seasonal transmission rate vector
+     rho = rnorm(1, 0.5, 0.06),  # reporting fraction, centered on ~0.5
+     inv_lambda = runif((ntimes-1), 0.9, 0.99),  # time-varying escape-from-infection probability vector
+     eta = runif(1, 0.001, 5),  # dispersion of negative binomial observation process
+     psi = runif(1, 0, 10),  # influx of infection
+     sigma_env = runif(1, 0.01, 1),  # std. dev. of noise on transmission rate
+     sigma_bsplines = runif(1, 0.0001, 2),  # std. dev. of bsplines for seasonality
+     varepsilon = runif((ntimes-1), 0.01, 0.8),  # amplitude of sin wave seasonality
+     S0 = rpois(1, 30000),  # initial condition for susceptible class
+     I0 = rpois(1, initI),  # initial condition for infected class
+     btrend = runif(1, -0.01, 0.01),
+     alpha = runif(6, -2, 2)
+   )
+ }
> 
> 
> # Run the MCMC ------------------------------------------------------------
> 
> # Set MCMC parameters
> n_adapt <- 100000  # iterations for adaptation phase
> n_update <- 100000  # iterations for burn-in to stationary distributions
> n_sample <- 100000  # iterations for sampling from posterior
> n_thin <- 10
> 
> # Set up cluster
> if(detectCores() < 3){  # make sure there are enough cores
+   stop("Too few cores on this machine for parallel MCMC.")
+ }
> 
> cl <- makeCluster(3)
> 
> # Run JAGS in parallel
> clusterExport(
+   cl,
+   c("jags_data", "generate_initial_values", "n_adapt", "n_update", "n_sample", "n_thin", "measles_model")
+ )
> 
> mcmc_results <- clusterEvalQ(
+   cl, {
+     library(rjags)  # reload rjags for each core
+     set.seed(1)
+     
+     # Initialize model in JAGS (adaptation phase)
+     model <- jags.model(
+       textConnection(measles_model),
+       data = jags_data,
+       n.chains = 1,
+       n.adapt = n_adapt
+     )
+     
+     # Update chain with long burn-in
+     update(model, n.iter = n_update)
+     
+     # Collect samples from posterior
+     vars_to_collect <- c(
+       "Iobs", "I", "S", "E", "beta_mu", "beta", "beta_season", "rho", 
+       "psi", "eta", "sigma_env", "S0", "I0", "alpha", "btrend"
+     )
+     
+     mcmc_core <- coda.samples(
+       model, 
+       variable.names = vars_to_collect, 
+       n.iter = n_sample, 
+       n.thin = n_thin
+     )
+     
+     return(as.mcmc(mcmc_core))
+   }  # end cluster-specific calls
+ )  # end cluster definition
> 
> mcmc_all <- mcmc.list(mcmc_results)  # grab all chains
> stopCluster(cl)  # stop the cluster
> 
> 
> # Summarize and save output -----------------------------------------------
> 
> ggs(mcmc_all) %>%
+   group_by(Parameter) %>%
+   summarise(
+     median_value = median(value),
+     upper_95 = quantile(value, 0.975),
+     lower_95 = quantile(value, 0.025),
+     upper_50 = quantile(value, 0.75),
+     lower_50 = quantile(value, 0.25)
+   ) %>%
+   write_csv(path = "./mcmc_results.csv")
> 
> saveRDS(object = mcmc_all, file = "mcmc_chains.RDS")
> 
> proc.time()
     user    system   elapsed 
 1422.634   136.634 13315.884 
