---
title: "Bayesian state-space SI model with year-specific, smooth seasonality"
author: "Andrew Tredennick"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, fig.height = 4)

library(tidyverse)  # data wrangling
library(lubridate)  # time and date functions
library(ggthemes)   # pleasing ggplot2 themes
library(rjags)      # Gibbs MCMC sampling algorithm for Bayesian models
library(ggmcmc)     # quick conversions of MCMC output to data frames
library(splines)    # fitting generalized additive (spline) models
library(viridis)    # pleasing color palette
library(spaero)     # project AERO code; EWS metrics, etc.

theme_set(theme_minimal())  # set ggplot2 theme globally
```

## The model
The idea is to fit a discrete-time state-space model following susceptible-infected (SI) dynamics.
Previous TSIR (time-series SIR) models allowed for seasonality in transmission rate, but that seasonality was shared among all years.
This creates problems when attempting to calculating time-varying quantities of interest, such as effective reproductive rate ($R_e$).
Here, I will implement a more flexible approach, where seasonality is incorporated with a smooth basis function (spline) that has year-specific parameters.

The model is as follows:

$$
y_t \sim \text{Binomial}(I_t, p) \\
I_{t+1} \sim \text{Negative Binomial}\left(\lambda_{t+1}, I_t \right), \\
S_{t+1} = S_t - I_{t+1} + b_t,\\
\lambda_{t+1} = \beta_t I_t^\alpha z_t^\epsilon, \\
\beta_t = \mu_{y(t)} + \sum^J_{j=1} \mathbf{W}\eta_{j,y(t)}, \\
\mu_{y(t)} \sim \text{Normal}(0,1), \\
\eta_{y(t)} \sim \text{Normal}(0,1),
$$

where the determinstic equation for the force of infection ($\lambda$) can be transformed to a linear equation by log transformation: $\text{log}(\lambda_{t+1}) = \text{log}(\beta_t) + \alpha \times \text{log}(S_t) + \epsilon \times \text{log}(z_t)$.
The time-varying rate of transmission ($\beta_t$) is modeled as a basis function to allow for seasonality (curvature within the year) that is specific to each year (different seasonality for each year).
I chose spline bases for $\mathbf{W}$ beause they are a simple choice for implementing nonlinear effects.
I chose to use three knots ($J = 3$) for this initial attempt because that allows for sufficient curvature without letting the function wiggle around too much.
The optimal value for $J$ can be found via model selection if this looks promising.

| Parameter | Definition | 
| --------- | ----------------------------------|
| $I_t$ | Number of infected individuals at time *t* (latent). |
| $S_t$ | Number of susceptible individuals at time *t* (latent). |
| $y_t$ | Number of reported cases at time *t* (observed). |
| $p$ | Reporting fraction. |
| $b_t$ | Number of births at time *t*. |
| $\lambda_t$ | Force of infection at time *t*. |
| $\beta_t$ | Transmission rate at time *t*. |
| $\alpha$ | Something about mixing. |
| $\epsilon$ | Something... |
| $\mu_{y(t)}$ | Mean of the basis function for $\beta$ in year *y* associated with time *t*. |
| $\eta_{j,y(t)}$ | Basis function coefficient for knot *j* in year *y* associated with time *t*. |
| $\mathbf{W}$ | Matrix of basis vectors |

## Fitting the model
I will use a subset of the Niger measles data that come from the capitol, Niamey.

```{r load-data}
file_name <- "../niger_measles/niger_regional_1995_2005.csv"
niger_measles_raw <- read_csv(file_name, col_types = cols())

num_regions <- nrow(niger_measles_raw)
num_weeks <- ncol(niger_measles_raw) - 1  # subtract 1 from ncol() because first column are regions

# Create a vector of dates for each week over 11 years
start_date <- ymd("19950101")
all_dates <- seq(start_date, by = "week", length.out = num_weeks)

# Clean up the data frame
measles_dat <- niger_measles_raw %>%
  gather(key = week, value = cases, -X1) %>%
  mutate(
    week_num = rep(1:num_weeks, each = num_regions),
    date = rep(all_dates, each = num_regions)
  ) %>%
  dplyr::rename(region = X1) %>%
  dplyr::select(-week) %>%
  filter(region == "Niamey (City)")

# Plot the time series
ggplot(measles_dat, aes(x = date)) +
  geom_ribbon(aes(ymax = cases, ymin = 0), fill = "grey35") +
  labs(x = "Date", y = "Reported cases") +
  ggtitle("Reported cases of measles", subtitle = "Niamey, Niger")
```

There are a couple pre-processing steps necessary before fitting the model:

1. Estimate biweekly births ($b_t$).
2. Reconstruct the susceptible dynamics ($z_t$).
3. Define the basis vectors ($\mathbf{W}$).

### 1. Estimate biweekly births
This seems a little awkward, but here is my plan.
We know the estimated annual birth rate in Niger is 50.73 births per 1000 people, or `r round(50.73/1000,2)` per person per year.
Assuming this is relatively constant through time, we can apply this rate to annual estimates of the total population in Niamey.
Unfortunately, annual population estimates are hard to come by.
So, I will fit a linear trend between population estimates and use that trend to estimate population size in unobserved years.
I will then multiply the annual per capita birth rate (*r* = `r round(50.73/1000,2)`) by the yearly population estimates ($\hat{N_y}$) to obtain the number of births for each year.
Then I divide by the number of weeks in a year ($\overline{w}$ = 52.1429 weeks, on average) to arrive at the number of births in each week *t*:

$$
b_t = \frac{r \hat{N}_{y(t)}} {\overline{w}},
$$

where $y(t)$ reads "year *y* associated week *t*."

```{r calc-births}
# Estimate population size
niamey_pop <- tibble(
  year = c(2001, 2012),
  population = c(707951, 1026800)  # from UN DATA, via Google
)

poptrend <- lm(population~year, data = niamey_pop)
poppreds <- round(predict(poptrend, newdata = data.frame(year = 1995:2005)))


# Estimate weekly birth rates
percap_birth_rate <- 50.73/1000
avg_weeks <- 52.1429

niamey_pop_preds <- tibble(
  Year = 1995:2005,
  `Population Size` = poppreds
) %>%
  mutate(
    `Weekly Births` = percap_birth_rate * `Population Size` / avg_weeks
  ) %>%
  gather(key = variable, value = value, -Year)


# Plot the estimates
ggplot(niamey_pop_preds, aes(x = Year, y = value)) +
  geom_line() +
  geom_point(size = 3) +
  facet_wrap(~variable, scales = "free_y") +
  scale_x_continuous(breaks = seq(1995,2005,2)) +
  labs(x = "Year", y = "Number of people or births") +
  ggtitle("Estimates of population size and weekly births", subtitle = "Niamey, Niger")

```

### 2. Reconstruct the susceptible dynamics
We don't actually know the number of susceptibles (*S*) at each time point, but we can recover their temporal dynamics, allowing us to recover the latent *S* state after estimating only one quantity, the mean number of susceptibles ($\overline{S}$).

### 3. Define the basis vectors
We need to define the basis vectors that will be multipled by the basis coefficients to generate the smooth seasonal curves for rate of transmission.
These values form the matrix $\mathbf{W}$ that will be fed into the model fitting algorithm as knowns.

```{r basis-functions}
num_weeks <- 52
num_knots <- 3
bases <- bs(1:num_weeks, knots = num_knots)

bases_df <- tibble(
  week_num = 1:52,
  base_1 = bases[,1],
  base_2 = bases[,2],
  base_3 = bases[,3],
  base_4 = bases[,4]
) %>%
  gather(key = base_id, value = value, -week_num)

ggplot(bases_df, aes(x = week_num, y = value, color = base_id)) +
  geom_line(size = 1) +
  scale_color_colorblind() +
  guides(color = FALSE) +
  labs(x = "Week", y = "Basis function value")
```

### JAGS model
Here I define the JAGS model to be fit via MCMC.
This mode is called using the `rjags::jags.model()` function.

```{r jags-model}
measles_model <- "model{

# Data model
for(i in 1:num_obs){
  y[i] ~ dbinom(p, I[i])
}

# Process model

## TODO: get subscripting right here...
for(t in 1:ntimes){
  beta[t] <- mu[yr[t]] + inprod(W[t,], eta[yr[iweek],])  # spline model for rate of transmission
}


# Transmission rate
for(iyr in 1:nyrs){
  eta[iyr] ~ dnorm(0, 1)
  
  for(iweek in 1:(nweeks[iyr])){
    beta[iyr, iweek] <- mu[yr[iweek]] + inprod(W[iweek,], eta[yr[iweek],])  # spline model for rate of transmission
  }

}

# Priors

}"
```