---
title: "Standard EWS time-series analysis with spaero metrics"
author: "Andrew Tredennick"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output: html_document
---

```{r setup, message=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, fig.height = 4)

library(schoenberg)
library(tidyverse)   # data wrangling
library(lubridate)   # time and date functions
library(viridis)     # pleasing color palette
library(spaero)      # project AERO code; EWS metrics, etc.
library(mgcv)        # functions for fitting generalized additive models
library(MASS)        # additional distributions

theme_set(theme_minimal())  # set ggplot2 theme globally

```

## Goal and objectives
The goal of this analysis to test early warning signals (EWS) using real datasets -- can they detect outbreaks before they occur?
I will use regional-level data from Niger, focusing independently on each region for which data exists.
EWS metrics will be calculated using the `spaero` package.

```{r load-data}
file_name <- "../niger_measles/niger_regional_1995_2005.csv"
niger_measles_raw <- read_csv(file_name, col_types = cols())

num_regions <- nrow(niger_measles_raw)
num_weeks <- ncol(niger_measles_raw) - 1  # subtract 1 from ncol() because first column are regions
weeks_per_year <- num_weeks/11
weeks <- rep(1:52, times = 11)

# Create a vector of years for all num_weeks
years <- rep(1995:2005, each = weeks_per_year)

# Function for calculating start of week based on week number and year
calculate_start_of_week = function(week, year) {
  date <- ymd(paste(year, 1, 1, sep="-"))
  week(date) = week
  return(date)
}

# Clean up the data frame
measles_data <- niger_measles_raw %>%
  gather(key = week, value = cases, -X1) %>%
  mutate(
    week_num = rep(1:num_weeks, each = num_regions),
    year = rep(years, each  = num_regions),
    week = rep(weeks, each = num_regions),
    date = calculate_start_of_week(week, year)
  ) %>%
  dplyr::rename(region = X1)

# Plot the time series
ggplot(measles_data, aes(x = date, y = cases)) +
  geom_line() +
  labs(x = "Date", y = "Reported cases") +
  facet_wrap(~region)
```

## Example
Start with `region == "Tannout"` as exemplar.

```{r ews-tannout}
plot_st <- function(st, ts_freq) {
  # A function to plot results from spaero::get_stats()
  # Author:
  #  Eamon O'Dea
  
  plot_vars <- ts(
    cbind(
      Residual=st$centered$x[, 1], 
      Mean=st$stats$mean,
      Autocorrelation=st$stats$autocor,
      Variance=st$stats$variance,
      DeltaVariance=st$stats$variance_first_diff,
      Skewness=st$stats$skew
    ), 
    freq <- ts_freq
  )
  
  plot(plot_vars, main="")
}

tannout_data <- measles_data %>%
  filter(region == "Tannout")

ggplot(tannout_data, aes(x = date, y = cases)) +
  geom_col()

st1 <- get_stats(
  tannout_data$cases, 
  center_kernel = "uniform",
  center_trend = "local_constant", 
  center_bandwidth = 52,
  stat_bandwidth = 52
)

plot_st(st1, 52)
```

## Can we simulate the dynamics many times using GAMs?
The idea here is that we need to score our EWS like we do in the theoretical studies.
One way to do this is simulate the data-generating process many, many times, then apply EWS to those series, and see if they can detect transitions.
So we need to do a couple things:

1. Simulate the data generating process.
2. Define critical transitions.

We might be able to both with **generalized additive models**.

```{r gam-test}
gam_data <- tannout_data %>%
  mutate(
    month = month(date),
    time = as.numeric(date)/1000
  )

mod <- gamm( 
  # cases ~ s(month, bs = "cc", k = 12) + s(week_num), 
  cases ~ s(week_num, bs = "cr"), 
  correlation = corARMA(form = ~ week_num, p = 1), 
  family = "poisson",
  data = gam_data
)

new_data <- tibble(
  month = gam_data$month,
  week_num = sample(gam_data$week_num, size = nrow(gam_data), replace = FALSE)
)
preds <- predict(mod$gam, type = "response", se.fit = TRUE)

preds_tbl <- tibble(
  mean_prediction = preds$fit,
  upper_prediction = preds$fit + 2*preds$se.fit,
  lower_prediction = preds$fit - 2*preds$se.fit,
  observation = tannout_data$cases,
  date = tannout_data$date
)

ggplot(preds_tbl, aes(x = date)) +
  geom_point(aes(y = observation), col = "grey25", size = 1) +
  geom_line(aes(y = mean_prediction), col = "coral")

# library(MASS)
# Rbeta <- mvrnorm(n = 1000, coef(mod$gam), vcov(mod$gam))
# Xp <- predict(mod$gam, newdata = new_data, type = "lpmatrix")
# sim1 <- Xp %*% t(Rbeta)
# 
# set.seed(321)
# want <- sample(1000, 25)
# matplot(exp(sim1[,want]), col = "black", lty = 1, pch = NA, type = "l")
```

## Detect periods of change using derivatives
```{r change-detection}
mod_deriv <- fderiv(mod, n = nrow(tannout_data))
deriv_cis <- confint(mod_deriv, nsim = 20, type = "simultaneous") %>%
  as_tibble() %>%
  mutate(
    date = tannout_data$date
  )

ggplot(deriv_cis, aes(x = date, y = est)) +
  geom_ribbon(aes(ymin = lower, ymax = upper), alpha = 0.2, fill = "black") +
  geom_line() +
  geom_hline(aes(yintercept = 0)) +
  labs(x = "Date", y = "First derivative")

# library(MASS)
# Rbeta <- mvrnorm(n = 1000, coef(mod$gam), vcov(mod$gam))
# Xp <- predict(mod$gam, type = "lpmatrix")
# sim1 <- Xp %*% t(Rbeta)
# 
# set.seed(321)
# want <- sample(1000, 25)
# matplot(exp(sim1[,want]), col = "black", lty = 1, pch = NA, type = "l")
```
