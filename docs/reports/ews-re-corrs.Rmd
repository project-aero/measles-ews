---
title: "Correlations between EWS and effective reproduction number"
output: html_notebook
---

To complement the fixed window analysis focused on emergence and elimination events, we also want to show that the dynamics of EWS reflect those of $R_E$.
I estimated $R_E$ over the observations via particle filtering and state estimation.
Here, I read in those values for each city and correlate them with top-performing EWS.
Top-performing EWS are those with high AUC in the emergence and elimination scenarios.
Note that $R_E$ was calculated as:

$$
R_E = \frac{\beta_t}{(\gamma + \eta)} \frac{S_t}{N_t}.
$$

```{r load-re}
library(tidyverse)

cities <- c("Agadez", "Maradi", "Niamey", "Zinder")  # the four city names
reffs <- tibble()  # empty tibble for storage

for(do_city in cities){
  fname <- paste0("../../results/filtered-states-", do_city, ".RDS")
  raw_filter <- readRDS(fname)
  reff_id <- which(raw_filter$state == "effective_r_seasonal")
  tmp_reff <- raw_filter$data[[reff_id]] %>%
    dplyr::select(time, med, week, date) %>%
    dplyr::mutate(city = do_city)
  
  reffs <- bind_rows(reffs, tmp_reff)
}

ggplot(reffs, aes(x = date, y = med, color = city)) +
  geom_hline(aes(yintercept = 1), linetype = 2, color = "grey35") +
  geom_line() +
  labs(x = "date", y = expression(italic(R)[E]), 
       title = "Effective reproduction number over time") +
  ggthemes::scale_color_colorblind()
```

Now I calculate the EWS at each observation time using the `spaero::get_stats()` function.
I use a bandwidth of 35 weeks and set `backward_only = TRUE` so that only past data are used when calculating EWS.

```{r ews-calc}
library(spaero)

fname <- "../../data/clean-data/weekly-measles-incidence-niger-cities-clean.RDS"
measles_data <- readRDS(fname) %>%
  filter(year > 1994)  # drop first NA year, only used for modeling

all_stats <- tibble()  # empty tibble for storage

for(do_region in unique(measles_data$region)){
  
  cases <- measles_data %>%
    filter(region == do_region) %>%
    pull(cases)
  
  city_stats <- spaero::get_stats(
    x = cases,
    center_trend = "local_constant", 
    center_kernel = "uniform", 
    center_bandwidth = 35, 
    stat_trend = "local_constant", 
    stat_kernel = "uniform", 
    stat_bandwidth = 35, 
    lag = 1, 
    backward_only = TRUE
  )$stats
  
  city_stats_tb <- as_tibble(city_stats) %>%
    mutate(
      time_iter = 1:n(),
      date = unique(measles_data$date)
    ) %>%
    gather(key = ews, value = value, -time_iter, -date) %>%
    mutate(region = do_region)
  
  all_stats <- bind_rows(all_stats, city_stats_tb)
}

best_ews <- c("autocorrelation", "autocovariance", "mean", "variance")
all_stats <- all_stats %>%
  dplyr::filter(ews %in% best_ews)
```

Now I look at scatterplots of $R_E$ versus EWS.

```{r scatters}
reffs <- reffs %>%
  dplyr::mutate(region = paste0(city, " (City)")) %>%
  dplyr::select(-city)

ews_reffs <- left_join(all_stats, reffs)

ggplot(ews_reffs, aes(x = med, y = value, color = region)) +
  geom_point(alpha = 0.6) +
  facet_wrap(~ews, scales = "free") +
  ggthemes::scale_color_colorblind()

for(do_region in unique(ews_reffs$region)){
  print(ggplot(filter(ews_reffs, region == do_region & ews == "variance"), 
       aes(x = med, y = value, color = lubridate::week(date))) +
    geom_point() +
    facet_wrap(~lubridate::year(date), scales = "free") +
    labs(x = expression(R[E]), y = "EWS value", title = do_region) +
    scale_color_viridis_c(name = "week of year", direction = 1))
}
```

So those plots are pretty weird because of the temporal cycling.
What if I remove the seasonal component via differencing?

```{r rm-seas}
test <- filter(ews_reffs, region == "Maradi (City)" & ews == "variance") %>% 
  dplyr::mutate(value = dplyr::lag(value, n = 20))

test_reff <- diff(test$med)
test_ews <- diff(test$value) 

plot(test_reff, test_ews)
cor(test_reff, test_ews, method = "spearman", use = "pairwise.complete.obs")
```

# Rolling correlation?
The region-specific plots of $R_E$ and variance over time make it look like they are correlated at some points and not correlated at others.
Wonder if a rolling correlation can do the trick?

```{r roll-corr}
do_region <- "Zinder (City)"
variances <- ews_reffs %>%
  filter(ews == "variance" & region == do_region) %>%
  pull(value)

reffs <- ews_reffs %>%
  filter(ews == "variance" & region == do_region) %>%
  pull(med)

cases <- measles_data %>%
    filter(region == do_region) %>%
    pull(cases)

par(mfrow = c(2, 1))
plot(reffs, type = "l")
plot(variances, type = "l")

test <- zoo::rollapply(data.frame(variances,reffs), 10, function(x) cor(x[,1],x[,2]), by.column=FALSE)

df <- tibble(x = test, y = reffs[10:length(reffs)])
ggplot(df, aes(x = seq_along(x), y = y, color = x)) +
  geom_line(color = "grey35", size = 0.3) +
  geom_point() +
  geom_hline(aes(yintercept = 1), linetype = 2, color = "grey45") +
  scale_color_viridis_c(limits = c(-1,1), name = expression(paste("cor(", R[E], ", var)"))) +
  labs(x = "time", y = expression(R[E]))

# df <- tibble(x = variances[10:length(reffs)], y = reffs[10:length(reffs)])
# ggplot(df, aes(x = seq_along(x), y = y, color = sqrt(x))) +
#   geom_line(color = "grey35", size = 0.3) +
#   geom_point() +
#   geom_hline(aes(yintercept = 1), linetype = 2, color = "grey45") +
#   scale_color_viridis_c(name = "variance") +
#   labs(x = "time", y = expression(R[E]))
# 
# df <- tibble(x = variances, y = cases)
# ggplot(df, aes(x = seq_along(x), y = y, color = sqrt(x))) +
#   geom_line(color = "grey35", size = 0.3) +
#   geom_point() +
#   geom_hline(aes(yintercept = 1), linetype = 2, color = "grey45") +
#   scale_color_viridis_c(name = "variance") +
#   labs(x = "time", y = "cases")

```
