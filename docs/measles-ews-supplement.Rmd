---
csl: science-without-titles.csl
fontsize: 11pt
geometry: margin=1in
header-includes:
 - \usepackage{amsmath,amssymb}
 - \usepackage{changepage}
 - \usepackage{textcomp,marvosym}
 - \usepackage{cite}
 - \usepackage{nameref,hyperref}
 - \usepackage[left]{lineno}
 - \usepackage{microtype}
 - \DisableLigatures[f]{encoding = *, family = * }
 - \usepackage[table]{xcolor}
 - \usepackage{array}
 - \usepackage[font=small,labelfont=bf]{caption}
 - \usepackage{lastpage,fancyhdr,graphicx}
 - \usepackage{epstopdf}
 - \usepackage{mathptmx} 
 - \usepackage{longtable,booktabs}
 - \usepackage[symbol]{footmisc}
 - \usepackage{float}
 - \floatplacement{figure}{H}
layout: 11pt
linkcolor: black
output:
  pdf_document:
    fig_caption: yes
    keep_tex: no
urlcolor: black
bibliography: /Users/atredenn/Dropbox/Bibliography/measles-ews.bib
---
\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\renewcommand{\theequation}{S.\arabic{equation}}
\renewcommand{\thetable}{S\arabic{table}}
\renewcommand{\thefigure}{S\arabic{figure}}
\renewcommand{\thesection}{Section S\arabic{section}}

\raggedright
\vspace*{0.2in}

\begin{centering}

{\LARGE
\textbf\newline{SUPPLEMENTAL INFORMATION FOR:\\Title} 
}

\vspace{2em}

Andrew T. Tredennick, others

\end{centering}


# Stochastic simulations from the fitted models

Here we show stochastic simulations from the fitted models.
Simulations are all initialized from the same initial conditions, which were estimated as part of model fitting.

```{r stoch-sims, message=FALSE, warning=FALSE, echo = FALSE, fig.cap="Stochastic simulations from the fitted models. Each colored line is a single realization of the model from the same initial conditions. Ten simulations are shown. The black lines are the observed data. We do not expect model simulations to perfectly align with the data because of the multiple sources of stochasticity present. Thus, these simulations should be judged by their ability to reproduce dynamical features of the data.", fig.width=8.5, fig.height=4}
library(tidyverse)
library(stringr)
library(dplyr)
library(pomp)

code_files <- list.files("../code/")
pomp_ids <- grep("measles-pomp-object", code_files)
pomp_files <- code_files[pomp_ids]

results_files <- list.files("../results/")
mle_ids <- grep("mif-lls", results_files)
mle_files <- results_files[mle_ids]
boot_ids <- grep("boot", mle_files)
mle_files <- mle_files[-boot_ids]

all_sims <- tibble()
for(do_file in pomp_files){
  tmp_city <- str_sub(do_file, start = 21, end = nchar(do_file)-4)
  tmp_pomp <- readRDS(paste0("../code/", do_file))
  
  city_mle_ids <- grep(tmp_city, mle_files)
  tmp_mles <- read.csv(paste0("../results/", mle_files[city_mle_ids])) %>%
    drop_na() %>%
    filter(loglik == max(loglik))
  
  tmp_sim <- simulate(
    tmp_pomp,
    params = unlist(tmp_mles),
    nsim = 10,
    as.data.frame = TRUE,
    include.data = TRUE
  ) %>%
    dplyr::select(time, sim, reports, S) %>%
    mutate(city = tmp_city) %>%
    filter(time >= 1995)
  
  all_sims <- bind_rows(all_sims, tmp_sim)
}

ggplot() +
  geom_line(data = filter(all_sims, sim != "data"), aes(x = time, y = reports, color = sim), alpha = 0.25) +
  geom_line(data = filter(all_sims, sim == "data"), aes(x = time, y = reports)) +
  guides(color = FALSE) +
  facet_wrap(~city, scales = "free_y") +
  labs(x = "Date", y = expression(sqrt(Reports))) +
  scale_y_sqrt() +
  theme_minimal()
```

# Estimating the timing of critical transitions
To define the null and test intervals for our simulations of re-emergence and elimination, we need to know when the critical transition between alternative modes of fluctuation occurs.
For re-emergence, we defined the year of the critical transition as the year just after the effective reproduction number ($R_E$) reaches or exceeds the critical value of 1. 
For example, if $R_E$ reaches or exceeds 1 at some point during the fifth year of the simulation, then the critical transition year is defined as the sixth year of the simulation. 
Thus, the simulated data for calculating early warning signals ends at the end of the fifth year.
We call this year the ``critical year.''
From this full window, from the beginning of the simulation to the end of the critical year, we defined the null interval as the first half of the window (far from $R_E = 1$) and the test interval as the second half of the full window (near $R_E = 1$).
Figure Sx shows a typical example.

```{r emerge-windows, message=FALSE, warning=FALSE, echo = FALSE, fig.cap="A typical emergence simulation for Maradi where the initial number of susceptibles was discounted by 1e-04. (**A**) The simulated trajectory of $R_E$ and the year in which $R_E$ first reaches the critical value of 1 (denoted by dashed blue line). (**B**) The simulated trajectory of the number of cases. Note that the x-axis has been reduced relative to the top panel. The two vertical blue lines indicate the start (left-most line) and end (line for critical year) of the full window. The black line demarcates the division between the equal-length null and test intervals.", fig.width=6}
ex_file <- "../simulations/emergence-simulations-grid-Maradi-1e-04.RDS"
emerge_sim <- readRDS(ex_file)

re_one_year <- emerge_sim %>%
  group_by(time) %>%
  summarise(mean_re = mean(RE_seas)) %>%  
  mutate(year = round(time)) %>%  # create 'year' variable
  ungroup() %>%
  filter(mean_re >= 1) %>%  # drop times where Re less than 1
  filter(year == min(year) + 1) %>%  # filter to critical transition year
  distinct(year, .keep_all = TRUE) %>%  # drop duplicates
  dplyr::select(year) %>%
  ungroup()

re_path <- emerge_sim %>%
  group_by(time) %>%
  summarise(mean_re = mean(RE_seas)) %>%  
  mutate(year = round(time)) %>%  # create 'year' variable
  ungroup()

one_sim <- emerge_sim %>% 
  filter(sim == 1) %>%
  left_join(re_path) %>%
  mutate(used = ifelse(time <= re_one_year$year, "yes", "no"))

re_series <- ggplot(one_sim, aes(x = time, y = mean_re)) +
  geom_line(color = "tan", aes(alpha = used)) +
  geom_hline(aes(yintercept = 1), color = "grey35", linetype = 3) +
  geom_vline(aes(xintercept = re_one_year$year), color = "dodgerblue4", linetype = 2) +
  annotate(geom = "text", x = 9, y = 0.2, label = "critical\nyear", size = 3, color = "dodgerblue4") +
  scale_alpha_manual(values = c(0.4, 1)) +
  guides(alpha = FALSE) +
  labs(x = "Simulation time (year)", y = expression(R[E])) +
  theme_classic(base_size = 12)

cases_series <- ggplot(filter(one_sim, time < 11.5), aes(x = time, y = reports)) +
  geom_line(color = "tan", aes(alpha = used)) +
  geom_vline(aes(xintercept = 0), color = "dodgerblue4", linetype = 2) +
  geom_vline(aes(xintercept = re_one_year$year), color = "dodgerblue4", linetype = 2) +
  geom_vline(aes(xintercept = 7/2)) +
  annotate(geom = "text", x = 1.75, y = 250, label = "Null window") +
  annotate(geom = "text", x = 5.25, y = 250, label = "Test window") +
  scale_alpha_manual(values = c(0.4, 1)) +
  guides(alpha = FALSE) +
  annotate(geom = "text", x = 6.35, y = 150, label = "critical\nyear", size = 3, color = "dodgerblue4") +
  labs(x = "Simulation time (year)", y = "Reported cases") +
  theme_classic(base_size = 12)

outplot <- cowplot::plot_grid(re_series, cases_series, nrow = 2, align = "v", 
                              scale = 0.9, labels = "AUTO", label_size = 12)
print(outplot)
```

For simulations of disease elimination by increasing the vaccination coverage of the population, we define the critical time as the time at which vaccination coverage reaches the threshold needed for herd immunity.
This vaccination threshold is defined as $p = 1 - 1/R_0$.
Because our transmission function is seasonal, we first calculated time-specific $R_0$ as: $R_{0(t)} = \frac{\eta \beta_t \mu}{\nu(\eta+\nu)(\gamma+\nu)}$, where $1/\eta$ is the infectious period, $1/\gamma$ is the recovery period, $\beta_t$ is the time-specific rate of transmission, $\mu$ is the birth rate, and $\nu$ is the death rate. Only $\beta_t$ is estimated by our model. We set $1/\eta$ = 8 days, $1/\gamma$ = 5 days, and $\mu = \nu$ = 0.05.
Figure 2 in the main text shows these values.
We took a conservative approach for calculating the vaccination threshold by using the maximum value of $R_0(t)$, such that: $p = 1 - 1/\text{max}(R_{0(t)})$.
We set the time at which vaccination coverage is equal to *p* as the endpoint for the EWS analysis.
All elimination simulations had vaccination campaigns that started at year 50.
So, we define the test interval as the times between year 50 and the year at which vaccination coverage is equal to *p*.
We then defined the null interval as window with length equal to test interval and ending at year 49.
Figure Sx shows a typical example.

![ A typical elimination simulation for Maradi where the rate to full vaccination coverage is 1.5e-05. The null and test intervals are defined based on the time at which the vaccination campaign begins (year 50, black line) and the year at which vaccination coverage reaches the vaccination threshold for herd immunity (left-most dashed blue line). The beginning of the null interval is determined by the length of the series from time 50 to the time of herd immunity: the null interval ends at time 50 (when vaccination campaign begins) and starts at whatever time results in a series that is equal in length to the test interval. ](../figures/elimination-series-example.pdf){ width=\textwidth }

# Trends of early warning signals

Theory suggests that most EWS should increase as disease dynamics approach a critical transition from below (emergence).
When approaching the critical transition from above (elimination), less is known about the behavior of EWS, but theory does tell us that the mean and variance should decrease while the autocorrelation should increase (at least for SIR and SEIR models).
To confirm that the EWS are behaving as expected, and to document cases in which they do not, we plotted histograms of the EWS for the test and null intervals for both simulation types, emergence and elimination.

```{r ews-hists, message=FALSE, warning=FALSE, echo = FALSE, fig.cap="Histograms of EWS from emergence simulations where susceptible depletion fraction was 1e-04.", fig.height=5}
emerge_ews <- read.csv("../results/ews-emergence.csv") %>%
  filter(metric != "variance_first_diff" & susc_discount == 1e-04)  %>%
  mutate(metric = as.character(metric)) %>%
  mutate(
    metric = ifelse(metric == "variance", "Variance", metric),
    metric = ifelse(metric == "variance_first_diff", "Var. 1st Diff.", metric),
    metric = ifelse(metric == "autocovariance", "Autocovar.", metric),
    metric = ifelse(metric == "autocorrelation", "Autocorr.", metric),
    metric = ifelse(metric == "decay_time", "Decay time", metric),
    metric = ifelse(metric == "mean", "Mean", metric),
    metric = ifelse(metric == "index_of_dispersion", "Index of dis.", metric),
    metric = ifelse(metric == "coefficient_of_variation", "Coeff. var.", metric),
    metric = ifelse(metric == "skewness", "Skewness", metric),
    metric = ifelse(metric == "kurtosis", "Kurtosis", metric)
  )

gout <- list()
for(do_city in sort(unique(emerge_ews$city))){
  if(do_city != "Zinder"){
    gout[[do_city]] <- ggplot(filter(emerge_ews, city == do_city), aes(fill = half, x = value)) +
      geom_histogram(bins = 20) +
      facet_wrap(~metric, scales = "free", nrow = 1) +
      scale_fill_manual(values = c("tan", "dodgerblue4")) +
      theme_minimal(base_size = 8) +
      theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
      guides(fill = FALSE) +
      labs(y = "Count", x = "") +
      ggtitle(do_city)
  }

  if(do_city == "Zinder"){
    gout[[do_city]] <- ggplot(filter(emerge_ews, city == do_city), aes(fill = half, x = value)) +
      geom_histogram(bins = 20) +
      facet_wrap(~metric, scales = "free", nrow = 1) +
      scale_fill_manual(values = c("tan", "dodgerblue4"), labels = c("Null", "Test"), name = NULL) +
      theme_minimal(base_size = 8) +
      theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
      labs(y = "Count", x = "EWS value") +
      ggtitle(do_city)
  }

}

ews_hists <- cowplot::plot_grid(
  plotlist = gout,
  nrow = 4,
  labels = "AUTO"
)
print(ews_hists)
```

```{r ews-hists2, message=FALSE, warning=FALSE, echo = FALSE, fig.cap="Histograms of EWS from elimination simulations where rate of vaccination coverage reaching 1 is 1.5e-05.", fig.height=5}
elimination_ews <- read.csv("../results/ews-elimination.csv") %>%
  filter(metric != "variance_first_diff" & vacc_speed == 1.5e-05) %>%
  mutate(metric = as.character(metric)) %>%
  mutate(
    metric = ifelse(metric == "variance", "Variance", metric),
    metric = ifelse(metric == "variance_first_diff", "Var. 1st Diff.", metric),
    metric = ifelse(metric == "autocovariance", "Autocovar.", metric),
    metric = ifelse(metric == "autocorrelation", "Autocorr.", metric),
    metric = ifelse(metric == "decay_time", "Decay time", metric),
    metric = ifelse(metric == "mean", "Mean", metric),
    metric = ifelse(metric == "index_of_dispersion", "Index of dis.", metric),
    metric = ifelse(metric == "coefficient_of_variation", "Coeff. var.", metric),
    metric = ifelse(metric == "skewness", "Skewness", metric),
    metric = ifelse(metric == "kurtosis", "Kurtosis", metric)
  )

gout <- list()
for(do_city in sort(unique(emerge_ews$city))){
  if(do_city != "Zinder"){
    gout[[do_city]] <- ggplot(filter(elimination_ews, city == do_city), aes(fill = half, x = value)) +
      geom_histogram(bins = 20) +
      facet_wrap(~metric, scales = "free", nrow = 1) +
      scale_fill_manual(values = c("tan", "dodgerblue4")) +
      theme_minimal(base_size = 8) +
      theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
      guides(fill = FALSE) +
      labs(y = "Count", x = "") +
      ggtitle(do_city)
  }

  if(do_city == "Zinder"){
    gout[[do_city]] <- ggplot(filter(elimination_ews, city == do_city), aes(fill = half, x = value)) +
      geom_histogram(bins = 20) +
      facet_wrap(~metric, scales = "free", nrow = 1) +
      scale_fill_manual(values = c("tan", "dodgerblue4"), labels = c("Null", "Test"), name = NULL) +
      theme_minimal(base_size = 8) +
      theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
      labs(y = "Count", x = "EWS value") +
      ggtitle(do_city)
  }

}

ews_hists <- cowplot::plot_grid(
  plotlist = gout,
  nrow = 4,
  labels = "AUTO"
)
print(ews_hists)
```

# Bootstrapped parameter confidence intervals

We used a bootstrap approach to estimate approximate 95\% confidence intervals for all parameters.
Below we show summary statistics for all parameters except the B-splines.
For B-splines, and transmission rate more gerenally, we plot the seasonal transmission rate function for all bootstrap replicates.

```{r param-summaries, message=FALSE, warning=FALSE, echo = FALSE, results = "asis"}

# Define computation grid -------------------------------------------------

nboots <- 100
nmifs <- 50
comp_grid <- expand.grid(1:nboots, 1:50)
colnames(comp_grid) <- c("boot_series", "param_set")
comp_grid$do_grid <- 1:nrow(comp_grid)


# Load loglikelihood results and combine ----------------------------------

loglik_files <- list.files("../results/", pattern = "bootstrap-mif-lls")
param_summaries <- tibble()

for(do_file in loglik_files){
  do_city <- str_sub(do_file, 19, -5)
  tmp_file <- read.csv(paste0("../results/", do_file)) %>%
    slice(2:n()) %>%  # ignore first row of NAs
    left_join(comp_grid, by = "do_grid") %>%  # merge in comp grid info
    group_by(boot_series) %>%
    filter(loglik == max(loglik)) %>%
    ungroup() %>%
    dplyr::select(-do_grid, -loglik, -loglik_se, -boot_series, -param_set,
                  -b1, -b2, -b3, -b4, -b5, -b6) %>%
    gather(key = parameter, value = mle_value) %>%
    group_by(parameter) %>%
    summarise(
      mean_value = mean(mle_value),
      median_value = median(mle_value),
      std_dev = sd(mle_value),
      upper_95_ci = quantile(mle_value, 0.975),
      lower_95_ci = quantile(mle_value, 0.025)
    ) %>%
    mutate(city = do_city)
  
  param_summaries <- bind_rows(param_summaries, tmp_file)
}

# Load example pomp file for basis function
pomp_file <- "../code/measles-pomp-object-Agadez.RDS"
measles_pomp <- readRDS(pomp_file)  # exemplar bases


# Calculate seasonal transmission functions -------------------------------

bases <- as_tibble(measles_pomp@covar) %>%
  dplyr::select(starts_with("x")) %>%
  dplyr::slice(1:365) %>%
  mutate(
    day = 1:365
  ) %>%
  gather(key = base, value = value, -day)

season <- bases %>%
  spread(key = base, value = value) %>%
  dplyr::select(-day) %>%
  as.matrix()

seasonal_functions <- tibble()
for(do_file in loglik_files){
  do_city <- str_sub(do_file, 19, -5)
  
  b_splines <- read.csv(paste0("../results/", do_file)) %>%
    slice(2:n()) %>%  # ignore first row of NAs
    left_join(comp_grid, by = "do_grid") %>%  # merge in comp grid info
    group_by(boot_series) %>%
    filter(loglik == max(loglik)) %>%
    ungroup() %>%
    dplyr::select(b1, b2, b3, b4, b5, b6)
  
  betas <- read.csv(paste0("../results/", do_file)) %>%
    slice(2:n()) %>%  # ignore first row of NAs
    left_join(comp_grid, by = "do_grid") %>%  # merge in comp grid info
    group_by(boot_series) %>%
    filter(loglik == max(loglik)) %>%
    ungroup() %>%
    dplyr::select(beta_mu)
  
  seasonal_betas <- tibble()
  for(i in 1:nrow(b_splines)){
    qis <- as.numeric(b_splines[i, ])
    beta_tmp <- as.numeric(betas[i, "beta_mu"])
    
    seasonal_tmp <- tibble(
      beta = as.numeric((1+exp(season %*% qis)) * beta_tmp),
      day = 1:365,
      boot = i
    )
    seasonal_betas <- bind_rows(seasonal_betas, seasonal_tmp)
  }  # end bootstrap loop
  
  seasonal_betas <- seasonal_betas %>%
    mutate(city = do_city)
  
  seasonal_functions <- bind_rows(seasonal_functions, seasonal_betas)
  
}  # end city loop

param_summaries <- param_summaries %>%
  mutate(
    parameter = ifelse(parameter == "beta_mu", "$\\beta$", parameter),
    parameter = ifelse(parameter == "beta_sd", "$\\sigma$", parameter),
    parameter = ifelse(parameter == "rho", "$\\rho$", parameter),
    parameter = ifelse(parameter == "iota", "$\\psi$", parameter),
    parameter = ifelse(parameter == "S_0", "$\\textsl{S}_{t=0}$", parameter),
    parameter = ifelse(parameter == "E_0", "$\\textsl{E}_{t=0}$", parameter),
    parameter = ifelse(parameter == "I_0", "$\\textsl{I}_{t=0}$", parameter),
    parameter = ifelse(parameter == "tau", "$\\tau$", parameter)
  ) %>%
  select(parameter, mean_value, median_value, std_dev, lower_95_ci, upper_95_ci, city) %>%
  rename(
    `Parameter` = parameter,
    `Mean` = mean_value,
    `Median` = median_value,
    `SD` = std_dev,
    `Upper 95% CI` = upper_95_ci,
    `Lower 95% CI` = lower_95_ci
  )
```

```{r param-tables, message=FALSE, warning=FALSE, echo = FALSE, results = "asis"}

for(do_city in unique(param_summaries$city)){
  tmp_table <- param_summaries %>%
  filter(city == do_city) %>%
  select(-city) %>%
  mutate_if(is.numeric, funs(as.character(signif(., 3))))

  docap <- paste0("Summary statistics of parameters from bootstrapped estimates for ", do_city, ".")
  print(knitr::kable(tmp_table, format = "pandoc", caption = docap))
}
```

```{r plot-seasonal-transmission, message=FALSE, warning=FALSE, echo = FALSE, fig.cap="Bootstrap replicates of estimated seasonal transmission functions.", fig.width=8.5, fig.height=3}

seasonal_functions <- seasonal_functions %>%
  mutate(
    date = as.Date(day, origin = "2016-12-31", tz = "UTC")
  )

ggplot(seasonal_functions, aes(x = date, y = beta, group = boot)) +
  geom_line(alpha = 0.3, color = "dodgerblue4") +
  labs(x = "Date", y = expression(paste("Tranmission rate, ",beta, " (", yr^-1, ")"))) +
  scale_x_date(date_labels = "%b", date_breaks = "2 months") +
  facet_wrap(~city, nrow = 1) +
  theme_minimal()

```
