---
title: "When to calculate early warning signals"
output: html_notebook
date: 2019-01-29
---

Given the seasonal trend in measles cases in all four cities in Niger, early warning signals calculated over the entire time series, without "zeroing out", simply reproduce lagged dynamics.
In other words, EWS calculated over the entire series are useless for prediction.
So, the goal here is to calculate EWS just during troughs in transmission: the months after a seasonal outbreak (whether large or small) but before the next seasonal outbreak (whether large or small).
EWS will be calculated for each season independently, meaning they are zeroed out at the beginning of each season.

The first task is to determine the months of low tranmission and months of high transmission.

```{r load-libs}
library(tidyverse)
library(lubridate)
library(spaero)
```

```{r plot-data}
data_file <- "../../data/clean-data/weekly-measles-incidence-niger-cities-clean.RDS" 
measles_data <- readRDS(data_file) %>%
  filter(year > 1994) %>%  # ignore first NA obs, just for modeling
  dplyr::select(-time)  # remove time col, just for modeling

ggplot(measles_data, aes(x = date, y = cases)) +
  geom_line() +
  facet_wrap(~region, scales = "free_y") +
  ggtitle("Measles cases over time")

ggplot(measles_data, aes(x = week_of_year, y = cases, group = year)) +
  geom_line() +
  geom_vline(aes(xintercept = 30), color = "red") +
  facet_wrap(~region, scales = "free_y") +
  ggtitle("Measles cases in each year, by week",
          subtitle = "red line shows beginning of trough")
```

Based on visual inspection, I've decided the beginning of the trough will be week 30 in each year.
So, for each year, I will calculate EWS starting at week 30 and running through until week 29.
This requires creating a new `season_year` column, as follows.

```{r season-year}
season_year_data <- measles_data %>%
  mutate(
    season_year = ifelse(week_of_year > 29, year + 1, year)
  )

ggplot(season_year_data, aes(x = week_of_year, y = log(cases+1))) +
  geom_line(aes(color = as.factor(season_year))) +
  facet_grid(year~region)
```

Now I can calculate the EWS based on `season_year` rather than calendar year or for the entire time series.

```{r calc-ews}
regions <- unique(season_year_data$region)
season_years <- unique(season_year_data$season_year)

all_ews <- tibble()  # empty tibble for storage
for(do_region in regions){
  for(do_season in season_years){
    tmp_data <- season_year_data %>%
      filter(region == do_region) %>%
      filter(season_year == do_season)
    
    tmp_cases <- tmp_data %>% pull(cases)
    tmp_stats <- get_stats(x = tmp_cases, center_trend = "local_constant", 
                           center_kernel = "uniform", center_bandwidth = 16,
                           stat_trend = "local_constant", 
                           stat_kernel = "uniform", stat_bandwidth = 16, 
                           lag = 1, backward_only = TRUE)
    
    tmp_out <- tmp_data %>%
      mutate(week_of_ews = 1:n()) %>%
      bind_cols(as_tibble(tmp_stats$stats))
    
    all_ews <- bind_rows(all_ews, tmp_out)
  }  # end season-year loop
}  # end region loop
```

Here's what the EWS look like.
Note that I am only focusing on a subset here: autocorrelation, variance, and mean.

```{r ews-plot}
ggplot(all_ews, aes(x = week_of_year, log(variance+1))) +
  geom_line(aes(color = as.factor(season_year))) +
  facet_grid(year~region)

ggplot(all_ews, aes(x = week_of_ews, y = log(variance+1))) +
  geom_line(aes(color = as.factor(year))) +
  facet_grid(season_year~region) +
  scale_x_continuous(breaks = seq(1, 52, by = 10),
                     labels = c(30,40,50,1,10,20))
```

Now we need threshold values at which to signal an early warning.
I will use the EWS values from the emergence simulations to define the threshold value for each EWS as the median value from the test interval where $R_E$ is approaching 1.

```{r get-thresholds}
ews_thresholds <- read_csv("../../results/ews-emergence.csv") %>%
  filter(susc_discount == 1e-04) %>%
  filter(half == "second") %>%
  group_by(metric, city) %>%
  summarise(
    med_value = quantile(value, 0.5),
    upr_value = quantile(value, 0.95),
    lwr_value = quantile(value, 0.05)
  ) %>%
  mutate(region = paste0(city, " (City)")) %>%
  dplyr::select(-city)

knitr::kable(ews_thresholds)
```

Now let's look at the variance plots again, this time with the threshold for signals layered in.

```{r var-and-thresh}
long_ews <- all_ews %>%
  gather(key = "ews_metric", value = "ews_value", 
         -region, -date, -year, -week_of_year, -obs_week, 
         -cases, -season_year, -week_of_ews)

just_med_threshold <- ews_thresholds %>%
  dplyr::select(-med_value, -lwr_value) %>%
  rename("threshold" = upr_value,
         "ews_metric" = metric)

long_ews <- long_ews %>%
  left_join(just_med_threshold, by = c("region", "ews_metric"))

ggplot(data = long_ews %>% filter(ews_metric == "variance", season_year > 1995), 
       aes(x = week_of_ews, y = ews_value)) +
  geom_line(aes(color = as.factor(year))) +
  geom_hline(aes(yintercept = threshold), linetype = 2) +
  geom_vline(aes(xintercept = 52-30+1), linetype = 2) +
  facet_grid(season_year~region) +
  scale_y_log10() +
  scale_x_continuous(breaks = seq(1, 52, by = 10),
                     labels = c(30,40,50,1,10,20))
```

Do a simple tally of years where the variance goes over the threshold before the new year (`week_of_ews = 1`).

```{r get-signals}
signal_tally <- long_ews %>%
  filter(season_year > 1995) %>%
  filter(week_of_year %in% c(30:52)) %>%
  mutate(
    warning = ifelse(ews_value >= threshold, TRUE, FALSE)
  )

signal_and_data <- long_ews %>%
  left_join(signal_tally %>%
              dplyr::select(region, date, week_of_ews, ews_metric, warning)) %>%
  filter(ews_metric %in% c("autocorrelation", "mean", "variance", "index_of_dispersion"))

ggplot(signal_and_data, aes(x = date, y = cases)) +
  geom_line(size = 0.25) +
  geom_vline(data = filter(signal_and_data, !is.na(warning)), 
             aes(xintercept = date, color = warning), size = 0.25, 
             linetype = 3, alpha = 0.75) +
  facet_wrap(ews_metric~region, scales = "free_y", ncol = 4) +
  scale_color_manual(values = c("blue", "red"))
```

For an omnibus statistic, I'm just going to sum the number of warnings at each point.

```{r omni-stat}
summed_signals <- signal_tally %>%
  filter(ews_metric %in% c("variance", "autocovariance", "autocorrelation", 
                           "decay_time", "mean", "index_of_dispersion")) %>%
  group_by(region, date, week_of_ews) %>%
  summarise(warnings = sum(as.numeric(warning), na.rm = TRUE))

summed_signals_data <- measles_data %>%
  left_join(summed_signals)

ggplot(summed_signals_data, aes(x = date, y = cases)) +
  geom_line(size = 0.5, color = ggthemes::ptol_pal()(1)) +
  geom_vline(data = filter(summed_signals_data, !is.na(warnings) & warnings >0), 
             aes(xintercept = date, color = warnings), size = 0.2, 
             linetype = 1) +
  scale_color_viridis_c(option = "A", name = "number of warnings\n(out of six possible)") +
  facet_wrap(~region, scales = "free_y", ncol = 1)
```

# Algorithm for outbreak risk
1. Number of warnings must NOT decrease over the interepidemic period.
2. 

# Warnings in simulated series
Now I will look at the simulated replicates to generate warnings from EWS using the same thresholds as above.
I can then look at relationships like: number of warnings vs. time from peak vs. peak cases.

```{r ews-on-sims}
# Load simulations
all_files <- list.files("../../simulations/")
sim_files <- all_files[grep("bootstrap", all_files)]

sim_data_all <- tibble()  # empty tibble for storage
for(do_file in sim_files){
  tmp_sim <- readRDS(paste0("../../simulations/", do_file)) %>% 
    unnest() %>%
    mutate(region = paste0(str_sub(do_file, 16, -5), " (City)")) %>%
    mutate(week_of_year = rep(1:52, times = max(sim)*11)) %>%
    dplyr::select(region, sim, time, week_of_year, reports)
  
  sim_data_all <- bind_rows(sim_data_all, tmp_sim)
}

# Make new year and season_year columns
sim_data <- sim_data_all %>%
  mutate(
    year = trunc(time),
    season_year = ifelse(week_of_year > 29, year+1, year)
  ) 
  # filter(sim < 51) %>%

# Calculate EWS for each season_year and simulation
regions <- unique(sim_data$region)
sims <- unique(sim_data$sim)
season_years <- unique(sim_data$season_year)

all_sim_ews <- tibble()  # empty tibble for storage
for(do_region in regions){
  for(do_sim in sims){
    for(do_season in season_years){
      tmp_data <- sim_data %>%
        filter(region == do_region) %>%
        filter(sim == do_sim) %>%
        filter(season_year == do_season)
      
      tmp_cases <- tmp_data %>% pull(reports)
      tmp_stats <- get_stats(x = tmp_cases, center_trend = "local_constant", 
                             center_kernel = "uniform", center_bandwidth = 16,
                             stat_trend = "local_constant", 
                             stat_kernel = "uniform", stat_bandwidth = 16, 
                             lag = 1, backward_only = TRUE)
      
      tmp_out <- tmp_data %>%
        mutate(week_of_ews = 1:n()) %>%
        bind_cols(as_tibble(tmp_stats$stats))
      
      all_sim_ews <- bind_rows(all_sim_ews, tmp_out)
    }  # end season-year loop
  }  # end simulation loop
}  # end region loop

long_sim_ews <- all_sim_ews %>%
  gather(key = "ews_metric", value = "ews_value", 
         -region, -sim, -time, -week_of_year, -reports, 
         -year, -season_year, -week_of_ews) %>%
  left_join(just_med_threshold, by = c("region", "ews_metric")) %>%
  filter(season_year > 1995) %>%
  filter(week_of_year %in% c(30:52)) %>%
  mutate(
    warning = ifelse(ews_value >= threshold, TRUE, FALSE)
  ) %>%
  filter(ews_metric %in% c("variance", "autocovariance", "autocorrelation", 
                           "decay_time", "mean", "index_of_dispersion")) %>%
  group_by(region, sim, season_year) %>%
  summarise(warnings = sum(warning, na.rm = TRUE))

# Calculate total number of cases in each season-year
cusum_sim_data <- sim_data %>%
  group_by(region, sim, season_year) %>%
  mutate(total_cases = sum(reports)) %>%
  filter(reports == max(reports)) %>%
  filter(week_of_year == min(week_of_year))

# Combine warning signals and data
sim_signals <- cusum_sim_data %>%
  left_join(long_sim_ews)

# Plot
ggplot(sim_signals, aes(x = log(warnings+1), y = log(total_cases+1))) +
  geom_point(color = "grey40") +
  stat_smooth(method = "lm", se = FALSE) +
  facet_wrap(~region)

broom::glance(lm(log(warnings+1)~log(total_cases+1), 
           data = sim_signals %>% filter(region == "Agadez (City)")))  
broom::glance(lm(log(warnings+1)~log(total_cases+1), 
           data = sim_signals %>% filter(region == "Maradi (City)")))  
broom::glance(lm(log(warnings+1)~log(total_cases+1), 
           data = sim_signals %>% filter(region == "Niamey (City)")))  
broom::glance(lm(log(warnings+1)~log(total_cases+1), 
           data = sim_signals %>% filter(region == "Zinder (City)")))  
```

# Weight the numnber of warnings by time
The idea here is to give more weight to warnings that occur closer to the beginning of the season.
I want to reduce the influence of warnings early in the interepidemic period because they may just be transient signals from the last season.
I also want to increase the influence of warnings late in the interepidemic period because these may be more representative of the state of the system leading in to the season.
This may help reduce the variation around the linear log-log trends shown above.
I am going to apply exponential weights to the value of time_index, which starts at 1 (`week_of_year = 30`) and goes to 23 (`week_of_year = 52`).

```{r weight-scheme}
time_index <- (30:52)-29
time_weight <- exp(time_index/max(time_index)) - 1
plot(time_index, time_weight)
```

```{r weight-ews}
# Add weights to all EWS df
weighted_sim_ews <- all_sim_ews %>%
  gather(key = "ews_metric", value = "ews_value", 
         -region, -sim, -time, -week_of_year, -reports, 
         -year, -season_year, -week_of_ews) %>%
  left_join(just_med_threshold, by = c("region", "ews_metric")) %>%
  filter(season_year > 1995) %>%
  filter(week_of_year %in% c(30:52)) %>%
  mutate(
    warning = ifelse(ews_value >= threshold, TRUE, FALSE)
  ) %>%
  filter(ews_metric %in% c("variance", "autocovariance", "autocorrelation", 
                           "decay_time", "mean", "index_of_dispersion")) %>%
  mutate(
    time_index = week_of_year - 29,
    time_weight = exp(time_index / max(time_index)) - 1
  ) %>%
  ungroup() %>%
  group_by(region, sim, season_year) %>%
  summarise(warnings = sum(warning*time_weight, na.rm = TRUE))


# Combine warning signals and data
sim_weighted_signals <- cusum_sim_data %>%
  left_join(weighted_sim_ews)

# Plot
ggplot(sim_weighted_signals, aes(x = log(warnings+1), y = log(total_cases+1))) +
  geom_point(color = "grey40") +
  stat_smooth(method = "lm", se = FALSE) +
  facet_wrap(~region)

broom::glance(lm(log(warnings+1)~log(total_cases+1), 
           data = sim_weighted_signals %>% filter(region == "Agadez (City)")))  
broom::glance(lm(log(warnings+1)~log(total_cases+1), 
           data = sim_weighted_signals %>% filter(region == "Maradi (City)")))  
broom::glance(lm(log(warnings+1)~log(total_cases+1), 
           data = sim_weighted_signals %>% filter(region == "Niamey (City)")))  
broom::glance(lm(log(warnings+1)~log(total_cases+1), 
           data = sim_weighted_signals %>% filter(region == "Zinder (City)")))  
```