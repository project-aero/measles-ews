---
title: "Correlations between EWS and effective reproduction number"
output: html_notebook
date: 2019-01-22
---

To complement the fixed window analysis focused on emergence and elimination events, we also want to show that the dynamics of EWS reflect those of $R_E$.
I estimated $R_E$ over the observations via particle filtering and state estimation.
Here, I read in those values for each city and correlate them with top-performing EWS.
Top-performing EWS are those with high AUC in the emergence and elimination scenarios.
Note that $R_E$ was calculated as:

$$
R_E = \frac{\beta_t}{\gamma} \frac{S_t}{N_t}.
$$

```{r load-re}
library(tidyverse)

cities <- c("Agadez", "Maradi", "Niamey", "Zinder")  # the four city names
reffs <- tibble()  # empty tibble for storage

for(do_city in cities){
  fname <- paste0("../../results/filtered-states-", do_city, ".RDS")
  raw_filter <- readRDS(fname)
  reff_id <- which(raw_filter$state == "effective_r_seasonal")
  tmp_reff <- raw_filter$data[[reff_id]] %>%
    dplyr::select(time, med, week, date) %>%
    dplyr::mutate(city = do_city)
  
  reffs <- bind_rows(reffs, tmp_reff)
}

ggplot(reffs, aes(x = date, y = med, color = city)) +
  geom_hline(aes(yintercept = 1), linetype = 2, color = "grey35") +
  geom_line() +
  labs(x = "date", y = expression(italic(R)[E]), 
       title = "Effective reproduction number over time") +
  ggthemes::scale_color_colorblind()
```

Now I calculate the EWS at each observation time using the `spaero::get_stats()` function.
I use a bandwidth of 35 weeks and set `backward_only = TRUE` so that only past data are used when calculating EWS.

```{r ews-calc}
library(spaero)

fname <- "../../data/clean-data/weekly-measles-incidence-niger-cities-clean.RDS"
measles_data <- readRDS(fname) %>%
  filter(year > 1994)  # drop first NA year, only used for modeling

all_stats <- tibble()  # empty tibble for storage

for(do_region in unique(measles_data$region)){
  
  cases <- measles_data %>%
    filter(region == do_region) %>%
    pull(cases)
  
  city_stats <- spaero::get_stats(
    x = cases,
    center_trend = "local_constant", 
    center_kernel = "uniform", 
    center_bandwidth = 16, 
    stat_trend = "local_constant", 
    stat_kernel = "uniform", 
    stat_bandwidth = 16, 
    lag = 1, 
    backward_only = TRUE
  )$stats
  
  city_stats_tb <- as_tibble(city_stats) %>%
    mutate(
      time_iter = 1:n(),
      date = unique(measles_data$date)
    ) %>%
    gather(key = ews, value = value, -time_iter, -date) %>%
    mutate(region = do_region)
  
  all_stats <- bind_rows(all_stats, city_stats_tb)
}

best_ews <- c("autocorrelation", "autocovariance", "mean", "variance")
all_stats <- all_stats %>%
  dplyr::filter(ews %in% best_ews)
```

Now I look at scatterplots of $R_E$ versus EWS.

```{r scatters}
reffs <- reffs %>%
  dplyr::mutate(region = paste0(city, " (City)")) %>%
  dplyr::select(-city)

ews_reffs <- left_join(all_stats, reffs)

ggplot(ews_reffs, aes(x = med, y = value, color = region)) +
  geom_point(alpha = 0.6) +
  facet_wrap(~ews, scales = "free") +
  ggthemes::scale_color_colorblind()

for(do_region in unique(ews_reffs$region)){
  print(ggplot(filter(ews_reffs, region == do_region & ews == "variance"), 
       aes(x = med, y = value, color = lubridate::week(date))) +
    geom_point() +
    facet_wrap(~lubridate::year(date), scales = "free") +
    labs(x = expression(R[E]), y = "EWS value", title = do_region) +
    scale_color_viridis_c(name = "week of year", direction = 1))
}
```

So those plots are pretty weird because of the temporal cycling.
What if I remove the seasonal component via differencing?

```{r rm-seas}
test <- filter(ews_reffs, region == "Agadez (City)" & ews == "variance") %>% 
  dplyr::mutate(value = dplyr::lag(value, n = 20))

test_reff <- test$med
test_ews <- log(test$value)
reff_ts <- ts(test_reff, frequency = 52)
ews_ts <- ts(test_ews, frequency = 52)
ews_ts[abs(ews_ts)==Inf] <- NA
ids <- which(!is.na(ews_ts))

ccf(ews_ts[ids], reff_ts[ids], type = "correlation", lag.max = 25, xlim = c(-25, 0)) 
abline(v = 0, col = "red", lty = 3)
plot(ews_ts[ids], reff_ts[ids])

# plot(test_reff, test_ews)
# cor.test(test_reff, test_ews, method = "spearman", use = "pairwise.complete.obs")
# 
# par(mfrow = c(2,1))
# plot(test_reff, type = "l")
# plot(test_ews, type = "l")
```

# Rolling correlation?
The region-specific plots of $R_E$ and variance over time make it look like they are correlated at some points and not correlated at others.
Wonder if a rolling correlation can do the trick?

```{r roll-corr}
do_region <- "Maradi (City)"
variances <- ews_reffs %>%
  filter(ews == "variance" & region == do_region) %>%
  pull(value)

reff_vec <- ews_reffs %>%
  filter(ews == "variance" & region == do_region) %>%
  pull(med)

cases <- measles_data %>%
    filter(region == do_region) %>%
    pull(cases)

par(mfrow = c(2, 1))
plot(reff_vec, type = "l")
plot(variances, type = "l")

test <- zoo::rollapply(data.frame(variances, reff_vec), 10, function(x) cor(x[,1],x[,2]), by.column=FALSE)

df <- tibble(x = test, y = reff_vec[10:length(reff_vec)])
ggplot(df, aes(x = seq_along(x), y = y, color = x)) +
  geom_line(color = "grey35", size = 0.3) +
  geom_point() +
  geom_hline(aes(yintercept = 1), linetype = 2, color = "grey45") +
  scale_color_viridis_c(limits = c(-1,1), name = expression(paste("cor(", R[E], ", var)"))) +
  labs(x = "time", y = expression(R[E]))

# df <- tibble(x = variances[10:length(reffs)], y = reffs[10:length(reffs)])
# ggplot(df, aes(x = seq_along(x), y = y, color = sqrt(x))) +
#   geom_line(color = "grey35", size = 0.3) +
#   geom_point() +
#   geom_hline(aes(yintercept = 1), linetype = 2, color = "grey45") +
#   scale_color_viridis_c(name = "variance") +
#   labs(x = "time", y = expression(R[E]))
# 
df <- tibble(x = reff_vec, y = cases)
ggplot(df, aes(x = seq_along(x), y = y, color = sqrt(x))) +
  geom_line(color = "grey35", size = 0.3) +
  geom_point() +
  geom_hline(aes(yintercept = 1), linetype = 2, color = "grey45") +
  scale_color_viridis_c(name = expression(R[E])) +
  labs(x = "time", y = "cases")

max_reffs <- ews_reffs %>%
  group_by(ews, region, lubridate::year(date)) %>%
  filter(med == max(med))

max_reffs <- ews_reffs %>%
  mutate(year = lubridate::year(date)) %>%
  group_by(year, ews, region) %>%
  dplyr::mutate(
    high_reff = ifelse(med > 1, TRUE, FALSE),
    value = ifelse(ews != "autocorrelation", log(value), value)
  )

hist(ews_reffs$med)

ggplot(max_reffs, aes(x = region, y = value, fill = high_reff)) +
  geom_boxplot() +
  facet_wrap(~ews, scales = "free_y")
```

# Differencing before correlating

```{r diffing}
do_region <- "Maradi (City)"
variances <- ews_reffs %>%
  filter(ews == "variance" & region == do_region) %>%
  pull(value)

reff_vec <- ews_reffs %>%
  filter(ews == "variance" & region == do_region) %>%
  pull(med)

reff_diffs <- diff(log(reff_vec))
var_diffs <- diff(variances)
cor(var_diffs, reff_diffs)
```

# Calculate EWS separately for each year starting in September, then correlate

```{r}
ggplot(measles_data, aes(x = week_of_year, y = cases, group = year)) +
  geom_line() +
  facet_wrap(~region, scales = "free")

measles_data <- measles_data %>%
  mutate(month = lubridate::month(date),
         season_year = ifelse(week_of_year < 29, year, year+1))

all_yearly_stats <- tibble()  # empty storage tibble
for(do_city in unique(measles_data$region)){
  for(do_year in unique(measles_data$season_year)){
    tmp_data <- measles_data %>%
      filter(region == do_city) %>%
      filter(season_year == do_year)
    
    tmp_cases <- tmp_data %>%
      pull(cases)
    
    tmp_stats <- spaero::get_stats(x = tmp_cases, 
                                   center_trend = "local_constant", 
                                   center_kernel = "uniform", 
                                   center_bandwidth = 35, 
                                   stat_trend = "local_constant", 
                                   stat_kernel = "uniform", 
                                   stat_bandwidth = 35, 
                                   lag = 1, backward_only = TRUE)$stats
    
    tmp_stats_tb <- as_tibble(tmp_stats) %>%
      mutate(
        time_iter = 1:n(),
        date = tmp_data$date
      ) %>%
      gather(key = ews, value = value, -time_iter, -date) %>%
      mutate(
        date = rep(tmp_data$date, length(tmp_stats)),
        season_year = do_year,
        region = do_city
      )
  
    all_yearly_stats <- bind_rows(all_yearly_stats, tmp_stats_tb)
  }  # end year loop
}  # end city loop

# Merge in effective R estimates
yearly_stats_ews <- all_yearly_stats %>%
  filter(ews %in% c("autocorrelation", "mean", "variance")) %>%
  left_join(reffs, by = c("date", "region")) %>%
  dplyr::select(-time_iter, -time) %>%
  left_join(measles_data, by = c("date", "season_year", "region")) %>%
  mutate(lag_re = dplyr::lag(med, n = 5)) %>%
  group_by(ews, region, year) %>%
  mutate(total_cases = sum(cases))

ggplot(filter(yearly_stats_ews, 
              region == "Zinder (City)" & 
                ews == "variance" &
                season_year > 1995 &
                month %in% c(8:12)), 
              aes(x = date, y = value)) +
  geom_line(size = 0.25) +
  geom_point(aes(color = med)) +
  scale_color_viridis_c() +
  facet_wrap(~year, scales = "free")

## LOOK AT THRESHOLDS AGAIN!!!!!!!!

# Look at CCF for variance
# var_tbl <- yearly_stats_ews %>%
#   filter(region == "Niamey (City)") %>%
#   filter(ews == "variance")
# 
# ews_ts <- ts(var_tbl$value, frequency = 52)
# reff_ts <- ts(var_tbl$med, frequency = 52)
# ccf(ews_ts, reff_ts, lag.max = 52, type = "correlation")

```

# Look at emergence simulations to find typical variance values 

First, identify outbreak and non-outbreak years.

```{r}
pop_data <- tibble(
  region = c("Agadez (City)", "Maradi (City)", "Niamey (City)", "Zinder (City)"),
  pop = c(118224, 267249, 1027000, 322935)
)

cusum_data <- measles_data %>%
  group_by(region, year) %>%
  summarise(cases = sum(cases)) %>%
  left_join(pop_data)

cusum_cases <- sort(cusum_data$cases / cusum_data$pop)
fit1 <- MASS::fitdistr(cusum_cases, "exponential") 

x <- cusum_cases
mixexplik <- function(p,lambda1,lambda2) {
  z <- p*dexp(x,lambda1) + (1-p)*dexp(x,lambda2)
  return(-sum(log(z)))
}

mle_fit <- suppressWarnings(  # ignore warnings about bad guesses
  stats4::mle(minuslogl = mixexplik, 
              start= list(p = 0.2,
                          lambda1 = as.numeric(fit1$estimate), 
                          lambda2 = as.numeric(fit1$estimate)), 
              method="Nelder-Mead")
)

bound <- qexp(p = 0.5, rate = mle_fit@coef["p"]*mle_fit@coef["lambda1"])

outbreak_ids <- cusum_data %>%
  dplyr::mutate(
    incidence = cases/pop,
    outbreak_year = ifelse(incidence < bound, FALSE, TRUE)
  ) %>%
  dplyr::select(region, year, outbreak_year)

outbreak_ids <- cusum_data %>%
  ungroup() %>%
  group_by(region) %>%
  mutate(
    max_cases = max(cases),
    outbreak_year = ifelse(cases >= 0.2*max_cases, TRUE, FALSE)
  ) 

ggplot(outbreak_ids, aes(x = year, y = cases, fill = outbreak_year)) +
  geom_col(position = "dodge") +
  facet_wrap(~region, scales = "free_y")

yearly_stats_ews <- yearly_stats_ews %>%
  left_join(outbreak_ids %>%
              dplyr::select(region, year, outbreak_year)) %>%
  ungroup()
```

Now calculate variance threshold as the median from the emergence simulations when close to $R_E=1$.

```{r}
do_city <- "Maradi"
do_ews <- "variance"

emerge_ews <- read_csv("../../results/ews-emergence.csv") %>%
  filter(susc_discount == 1e-04) %>%
  filter(half == "second") %>%
  filter(metric == do_ews)

# ggplot(emerge_ews, aes(x = city, y = log(value))) +
#   geom_boxplot()

variance_thresholds <- emerge_ews %>%
  group_by(city) %>%
  summarise(
    med_value = quantile(value, 0.5),
    lo_value = quantile(value, 0.05),
    hi_value = quantile(value, 0.95)
  )

ggplot() +
  geom_hline(data = filter(variance_thresholds, city == do_city), aes(yintercept = lo_value), linetype = 2) +
  geom_hline(data = filter(variance_thresholds, city == do_city), aes(yintercept = hi_value), linetype = 2) +
  geom_hline(data = filter(variance_thresholds, city == do_city), aes(yintercept = med_value)) +
  geom_point(data = filter(yearly_stats_ews, region == paste0(do_city," (City)") & 
                ews == do_ews &
                season_year > 1995 &
                month > 8),
              aes(x = date, y = value, color = outbreak_year)) +
  scale_y_log10() +
  facet_wrap(~year, scales = "free")
```
