---
title: "Profiling gamma random walk intensities"
author: "Andrew Tredennick"
output: html_notebook
date: 2019-02-05
---

We allow $\beta$ to talk a random walk in the final model filtering so that transmission rate can vary over time, if supported by the data.
I implemented the random walk using `pomp::rgammawn(lambda)` where `lambda` is the intensity of the perturbation.
To find the optimal level of `lambda`, I ran 10 replicate particle filters with 10,000 particles across a grid of `lambda` values.
I then calculated the mean log likelihood across the 10 replicate filters.

The results are below, showing the lower values of `lambda` result in higher likelihoods and better fits.
**This suggests that there is no trend in transmission rate, because the highest likelihood comes from models where transmission rate is not allowed to vary.**
However, I still need to test this finding with a few more MIF iterations, because allowing $\beta$ to take a random walk could alter other parameter estimates.

```{r, message = FALSE, warning = FALSE}
library(tidyverse)

read_csv("../../results/gamma_rw_logliks.csv") %>%
  ggplot(aes(x = rw_value, y = loglik)) +
  geom_point(size = 2, color = "grey35") +
  stat_smooth(se = FALSE, size = 0.5) +
  labs(x = "Lambda, pomp::rgammawn() intensity", y = "Log likelihood") +
  facet_wrap(~city, scales = "free_y")
```

To get an idea of the kind of variation that is happening at such low `lambda` values, I can simulate a Markovian process where $x_t = x_{t-1} \times \varepsilon_t$, where $\varepsilon_t \sim \text{Gamma}(\lambda)$ as implemented with `pomp::rgammawn()`.

```{r, message = FALSE, warning = FALSE, fig.height=5}
library(pomp)

lambda <- read_csv("../../results/gamma_rw_logliks.csv") %>%
  pull(rw_value) %>%
  min()  # optimal lambda value, which is minimum for all cities

xmean <- 300  # mean transmission rate, starting value
iters <- 5000  # number of time steps to simulate
x <- numeric(iters)  # storage vector
x[1] <- xmean  # initialize the vector
for(t in 2:iters){
  x[t] <- x[t-1] * pomp::rgammawn(n = 1, sigma = lambda, dt = 1)
}

par(mfrow = c(2,1))
plot(x, type = "l", ylab = "transmission rate", xlab = "iteration")
hist(pomp::rgammawn(n = 5000, sigma = lambda, dt = 1))
```


# Run extra MIF iterations
Here I run more MIF iterations, starting at the current MLE parameter set, to see if other parameters change when I allow $\beta$ to take a random walk, like above.
In this case, I let the `lambda` value be estimated by the model.

### Define the `pomp` model

```{r message=FALSE, warning=FALSE}
measles_process <- Csnippet(
  "
  // Define the variables
  int nrate = 3;          // number of rates
  double rate[nrate];	  	// transition rates
  double trans[nrate];   	// transition numbers
  double lambda;          // force of infection
  double beta;            // transmission rate
  double eta = 365/8;     // infectious rate (8 days latent)
  double gamma = 365/5;   // recovery rate (5 days infectious)
  double dW;              // white noise
  double seas;            // seasonality term
  double dN0S, dN0I, dNSE, dNEI, dNIR;  // transitions

  // Beta random walk
  beta_t *= rgammawn(rw_sigma, dt)/dt;

  // Calculate force of infection
  seas = (1 + exp(dot_product(K, &xi1, &b1)));
  beta = beta_t*seas;
  lambda = beta*I/N;

  // Gamma noise, mean=dt, variance=(beta_sd^2 dt)
  dW = rgammawn(beta_sd, dt);

  // Compute the transition rates
  rate[0] = lambda*dW/dt; // force of infection
  rate[1] = eta;          // infectious rate from latent
  rate[2] = gamma;	      // recovery from infectious

  // Compute the state transitions
  reulermultinom(1, S, &rate[0], dt, &trans[0]);
  reulermultinom(1, E, &rate[1], dt, &trans[1]);
  reulermultinom(1, I, &rate[2], dt, &trans[2]);

  // Transitions
  dN0S = rpois(0.3 * mu * N * dt);
  dN0I = rpois(iota * dt);
  dNSE = trans[0];
  dNEI = trans[1];
  dNIR = trans[2];

  // Balance the equations
  S += dN0S - dNSE;
  E +=        dNSE - dNEI;
  I += dN0I        + dNEI - dNIR;

  cases += dNIR;  // cases are cumulative reports at end of infectious period (I->R)
  if (beta_sd > 0.0)  W += (dW-dt)/beta_sd;
  RE = (beta_mu / gamma) * (S / N);
  RE_seas = (beta / gamma) * (S / N);
  "
)


# Define likelihood function ----------------------------------------------

measles_dmeasure <- Csnippet(
  "
  double mean;
  double f;
  mean = cases*rho;
  if (ISNA(reports)) {  // for catching missing observations
    lik = (give_log) ? 0 : 1;
  } else {
    f = dnbinom_mu(reports, 1/tau, mean, give_log);  // negative binomial likelihood
    // f = dpois(reports, mean, give_log);
  }

  lik = (give_log) ? log(f) : f;
  "
)


# Define process simulator for observations -------------------------------

measles_rmeasure <- Csnippet(
  "
  reports = rnbinom_mu(1/tau, rho*cases);  // negative binomial measurement process
  // reports = rpois(rho*cases);

  if (reports > 0.0) {
    reports = nearbyint(reports);
  } else {
    reports = 0.0;
  }
  "
)


# Define parameter transformation scales ----------------------------------

from_estimation <- Csnippet(
  "
  Tbeta_mu = exp(beta_mu);
  Tiota = exp(iota);
  Trho = expit(rho);
  Tbeta_sd = exp(beta_sd);
  TS_0 = expit(S_0);
  TE_0 = expit(E_0);
  TI_0 = expit(I_0);
  Ttau = exp(tau);
  Trw_sigma = exp(rw_sigma);
  "
)

to_estimation <- Csnippet(
  "
  Tbeta_mu = log(beta_mu);
  Tiota = log(iota);
  Trho = logit(rho);
  Tbeta_sd = log(beta_sd);
  TS_0 = logit(S_0);
  TE_0 = logit(E_0);
  TI_0 = logit(I_0);
  Ttau = log(tau);
  Trw_sigma = log(rw_sigma);
  "
)

initial_values <- Csnippet(
  "
  S = nearbyint(N*S_0);
  E = nearbyint(N*E_0);
  I = nearbyint(N*I_0);
  cases = 0.5*N*I_0;
  W = 0;
  RE = 0;
  RE_seas = 0;
  beta_t = beta_mu;
  "
)


# Make data tables --------------------------------------------------------

do_file <- "../../data/clean-data/weekly-measles-incidence-niger-cities-clean.RDS"

all_cities <- readRDS(do_file) %>%
  pull(region) %>%
  unique()

pomp_objects <- list()  # empty list for storing pomp objects
pomp_objects_null <- list()  # empty list for null pomp objects
for(do_city in all_cities){
  measles_data <- readRDS(do_file) %>%
    dplyr::filter(region == do_city)
  
  obs_data <- measles_data %>%
    dplyr::select(time, cases) %>%
    dplyr::rename(
      reports = cases
    )
  
  if(do_city == "Niamey (City)"){
    # REMOVE SUSPICIOUS DATA POINT AND REPLACE WITH MEAN OF NEIGHBORS #
    obs_data$reports[276] <- round(mean(obs_data$reports[c(275,277)]))
  }
  
  covar_file <- "../../data/clean-data/annual-demographic-data-niger-cities-clean.RDS"
  covar_data <- readRDS(covar_file) %>%
    dplyr::filter(region == do_city) %>%
    dplyr::select(time, population_size, birth_per_person_per_year) %>%
    dplyr::rename(
      N = population_size,
      mu = birth_per_person_per_year
    )
  
  # Generate basis functions for seasonality
  bspline_basis <- periodic.bspline.basis(
    covar_data$time,
    nbasis = 6,
    degree = 3,
    period = 1,
    names = "xi%d"
  ) %>%
    as_tibble()
  
  covar_data <- bind_cols(covar_data, bspline_basis)
  
  city_abb <- substr(do_city, start = 1, stop = 6)
  mle_file <- paste0("../../results/initial-mif-lls-", city_abb, ".csv")
  params <- read_csv(mle_file) %>%
    filter(loglik == max(loglik, na.rm = TRUE)) %>%
    dplyr::select(-do_grid, -loglik, -loglik_se) %>%
    unlist() %>%
    c(rw_sigma = 0.01)
  
  measles_pomp <- pomp(
    data = obs_data,
    times = "time",
    covar = covar_data,
    tcovar = "time",
    t0 = min(obs_data$time),
    rprocess = euler.sim(step.fun = measles_process, delta.t = 1/365),
    rmeasure = measles_rmeasure,
    dmeasure = measles_dmeasure,
    initializer = initial_values,
    statenames = c("S", "E", "I", "cases", "W", "RE", "RE_seas", "beta_t"),
    toEstimationScale = to_estimation,
    fromEstimationScale = from_estimation,
    paramnames = names(params),
    params = params,
    globals = "int K = 6;",
    zeronames = c("cases", "W")
  )

  city_abb <- substr(do_city, start = 1, stop = 6)
  pomp_objects[[city_abb]] <- measles_pomp
  
   params <- read_csv(mle_file) %>%
    filter(loglik == max(loglik, na.rm = TRUE)) %>%
    dplyr::select(-do_grid, -loglik, -loglik_se) %>%
    unlist() %>%
    c(rw_sigma = 0)
  
  measles_pomp_null <- pomp(
    data = obs_data,
    times = "time",
    covar = covar_data,
    tcovar = "time",
    t0 = min(obs_data$time),
    rprocess = euler.sim(step.fun = measles_process, delta.t = 1/365),
    rmeasure = measles_rmeasure,
    dmeasure = measles_dmeasure,
    initializer = initial_values,
    statenames = c("S", "E", "I", "cases", "W", "RE", "RE_seas", "beta_t"),
    toEstimationScale = to_estimation,
    fromEstimationScale = from_estimation,
    paramnames = names(params),
    params = params,
    globals = "int K = 6;",
    zeronames = c("cases", "W")
  )

  city_abb <- substr(do_city, start = 1, stop = 6)
  pomp_objects_null[[city_abb]] <- measles_pomp_null
}
```

### Perform MIF

Looking at the MIF traceplots, the log likelihood actually goes down from the initial parameter values.
And, logliks are larger for null models where I set rw_sigma = 0 (see table after this code snippet.

```{r, eval = TRUE, message=FALSE, warning=FALSE}
library(doParallel)
library(foreach)

registerDoParallel(cores = detectCores() - 1)


particles <- 10000
mif_iters <- 10

logliks <- foreach(i = names(pomp_objects), .combine = "rbind") %dopar% 
{
  mf <- pomp_objects[[i]] %>% 
    mif2(
      start = pomp_objects[[i]]@params,
      Nmif = mif_iters,
      Np = particles,
      transform = TRUE,
      cooling.fraction.50 = 1,
      cooling.type = "geometric",
      rw.sd = rw.sd(
        beta_mu = 0.02,
        beta_sd = 0.02,
        iota = 0.02,
        rho = 0.02,
        b1 = 0.02,
        b2 = 0.02,
        b3 = 0.02,
        b4 = 0.02,
        b5 = 0.02,
        b6 = 0.02,
        I_0 = ivp(0.1),
        E_0 = ivp(0.1),
        S_0 = ivp(0.1),
        tau = 0.02,
        rw_sigma = 0.02
      )
    ) 

    ll <- logmeanexp(replicate(5, logLik(pfilter(mf, Np = particles))), se=FALSE)
    ll_null <- logmeanexp(replicate(5, logLik(pfilter(pomp_objects_null[[i]], 
                                                      Np = particles))), se=FALSE)
    c(ll, ll_null)
  }

knitr::kable(as_tibble(logliks) %>%
               rename("random_walk" = V1,
                      "no_random_walk" = V2))
```